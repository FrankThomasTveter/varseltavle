{"ast":null,"code":"//console.log(\"Loading AutoLib.js\");\nfunction Auto() {\n  this.debug = false;\n  this.complete = true;\n\n  this.toggle = function (state) {\n    console.log(\"Pressed toggle\");\n    state.Auto.complete = !state.Auto.complete;\n    state.Show.showConfig(state);\n  }; // select given table key...\n\n\n  this.selectTableKey = function (state, key, keyval, keywhere, keycnt) {\n    // keep abscissa\n    if (this.debug) {\n      console.log(\"selectTableKey Entering:\", key, keyval, keywhere, keycnt, JSON.stringify(state.Path.keys));\n    }\n\n    ;\n    var ret = false;\n    var sid = state.Path.keys.other.indexOf(key); //console.log(\"SelectTableKey:\",key,sid,JSON.stringify(state.Path.keys.other));\n\n    if (sid !== -1 && key !== \"\") {\n      // key is selectable, but maybe not in table...\n      // why do you need duplicates of the target key (that will be removed)? \n      // - to check if the new selection makes your table keys redundant...\n      // You need to check the table keys again. \n      // We duplicate the target key into the table array and then remove both copies. \n      // This brings the old table keys back again, making them subject to a redundancy check.\n      var keys = state.Path.other.rest;\n      var lenk = keys.length;\n      var colkey = state.Path.getColKey(state);\n      var rowkey = state.Path.getRowKey(state);\n\n      if (this.debug) {\n        console.log(\"Autopath or not?:\", lenk, colkey, rowkey, sid, state.Auto.complete);\n      }\n\n      ;\n\n      if (lenk === 0 || colkey === undefined || rowkey === undefined || !state.Auto.complete) {\n        // nothing to consider\n        ret = state.Path.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n      } else {\n        state.Path.moveOther2Table(state, key); // move target key to front of array\n\n        state.Path.duplicateTableKey(state, key); // make duplicate\n\n        state.Path.exportAllKeys(state); //if(this.debug){console.log(\"Before:\",JSON.stringify(state.Path.keys));};\n\n        ret = state.Auto.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n        state.Path.exportAllKeys(state);\n        ret = state.Auto.tableKeyToPath(state, key, keyval, keywhere, keycnt); // remove duplicate\n      }\n    }\n\n    ;\n\n    if (ret) {\n      state.Path.exportAllKeys(state);\n    }\n\n    ;\n\n    if (this.debug) {\n      console.log(\"selectTableKey Done:\", JSON.stringify(state.Path.keys), JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  };\n\n  this.tableKeyToPath = function (state, key, keyval, keywhere, keycnt) {\n    //if(this.debug){console.log(\"tableKeyToPath Entering:\",key,keyval,keywhere,keycnt);};\n    // look for table-key candidates in the rest-stack\n    var ret, lens, jj, jkey, jkeyval, jkeywhere;\n    var analysis = this.analyse(state, key, keywhere); // move the key\n\n    ret = state.Path.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n\n    if (this.debug) {\n      console.log(\"Analysis:\", JSON.stringify(analysis));\n    }\n\n    ;\n\n    if (analysis.tblkey !== \"\") {\n      // we found a new table key\n      lens = analysis.sel.length;\n\n      for (jj = 0; jj < lens; jj++) {\n        jkey = analysis.sel[jj];\n        jkeyval = analysis.val[jj];\n        jkeywhere = jkey + \"='\" + jkeyval + \"'\";\n        state.Path.tableKeyToPath(state, jkey, jkeyval, jkeywhere, 1);\n      }\n\n      state.Path.keys.other = [analysis.othkey, analysis.tblkey].concat(state.Utils.clean(analysis.rest));\n    } else if (analysis.sel.length > 0 || analysis.rest.length > 0) {\n      // no target\n      lens = analysis.sel.length;\n\n      for (jj = 0; jj < lens; jj++) {\n        jkey = analysis.sel[jj];\n        jkeyval = analysis.val[jj];\n        jkeywhere = jkey + \"='\" + jkeyval + \"'\";\n        this.tableKeyToPath(state, jkey, jkeyval, jkeywhere, 1);\n      }\n\n      state.Path.keys.other = [analysis.othkey, \"\"].concat(state.Utils.clean(analysis.rest));\n    } else {\n      state.Path.keys.other = [analysis.othkey];\n    }\n\n    if (this.debug) {\n      console.log(\"tableKeyToPath Path:\", JSON.stringify(state.Path.keys));\n    }\n\n    ;\n\n    if (this.debug) {\n      console.log(\"tableKeyToPath Done:\", JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  };\n\n  this.analyse = function (state, trgkey, trgwhere) {\n    //if(this.debug){console.log(\"analyseOther Entering:\",JSON.stringify(trgkey),trgwhere);};\n    //other key\n    var keys = state.Path.other.rest;\n    var where = state.Database.getWhere(state);\n    var colkey = state.Path.getColKey(state);\n    var rowkey = state.Path.getRowKey(state);\n    var othkey = trgkey === colkey ? rowkey : colkey; // the other key\n\n    var sel = []; // selected\n\n    var val = []; // values\n\n    var rest = []; //rest\n\n    var tblkey = \"\"; // target key\n\n    var lenk = keys.length;\n    var keywhere = state.Database.addWhere(where, trgwhere); // redundant keys => selected\n    // insignificant keys => pushed back\n    // control keys => used in table\n\n    for (var ii = 0; ii < lenk; ii++) {\n      // first key dependencies\n      var testkey = keys[ii];\n\n      if (this.debug) {\n        console.log(\">>>Checking:\", testkey, \" vs Table:(\", trgkey, \",\", othkey, \") where=\", where, trgwhere);\n      }\n\n      ;\n      var othtable = [othkey, testkey];\n      var othdep = this.getDependancy(state, keywhere, othtable);\n\n      if (this.debug) {\n        console.log(\"        Other:   \", othkey, testkey, JSON.stringify(othdep));\n      }\n\n      ; // in case there are no targets\n\n      if (othdep.intprt[othkey] === \"insignificant\" || othdep.intprt[testkey] === \"insignificant\" || tblkey !== \"\") {\n        // ignore insignificant testkey\n        rest.push(testkey);\n\n        if (this.debug) {\n          console.log(\"****  Postpone:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey);\n        }\n\n        ;\n      } else if (othdep.intprt[testkey] === \"redundant\") {\n        // select redundant testkey\n        var testval = othdep.val[testkey];\n        sel.push(testkey);\n        val.push(testval);\n\n        if (this.debug) {\n          console.log(\"****  Select:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey, JSON.stringify(othdep), where);\n        }\n\n        ;\n      } else {\n        // control key\n        tblkey = testkey; // we have found a good candidate\n\n        if (this.debug) {\n          console.log(\"****  Target:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey);\n        }\n\n        ;\n      }\n    } //if(this.debug){console.log(\"Sel/Val:\",JSON.stringify(sel),JSON.stringify(val));};\n\n\n    var ret = {\n      sel: sel,\n      val: val,\n      rest: rest,\n      tblkey: tblkey,\n      othkey: othkey\n    };\n\n    if (this.debug) {\n      console.log(\"analyse Done:\", JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  }; // check if keys are inter-dependent, (\"common\", \"unique\", \"dependent\", \"unknown\") \n\n\n  this.getDependancy = function (state, where, keys) {\n    //if(this.debug){console.log(\"getDependancy Entering:\",where,JSON.stringify(keys));};\n    var key; //var where = state.Database.getWhere(state);\n\n    var ret = {\n      dep: {},\n      val: {}\n    };\n    var hits = {};\n    var maxhits = {};\n    var docs = state.Database.getDocsCnt(state, where, keys); // current table keys\n    //if(this.debug){console.log(\"getDependancy:\",JSON.strings(docs));};\n\n    var slen = keys.length;\n    var dlen = docs.length;\n\n    for (var ii = 0; ii < dlen; ii++) {\n      var doc = docs[ii];\n\n      for (var jj = 0; jj < slen; jj++) {\n        key = keys[jj];\n\n        if (doc[key] !== undefined) {\n          var val = doc[key];\n          ret.val[key] = val;\n\n          if (hits[key] === undefined) {\n            hits[key] = {};\n          }\n\n          hits[key][val] = 1 + (hits[key][val] || 0);\n\n          if (hits[key][val] > (maxhits[key] || 0)) {\n            maxhits[key] = hits[key][val];\n          }\n        }\n\n        ;\n      }\n    }\n\n    ; //if(this.debug){console.log(\"Hits:\",dlen,JSON.stringify(hits),where);};\n\n    for (var kk = 0; kk < slen; kk++) {\n      key = keys[kk];\n\n      if (maxhits[key] !== undefined) {\n        if (maxhits[key] === 1) {\n          // every entry has unique value\n          ret.dep[key] = \"unique\";\n        } else if (maxhits[key] === dlen) {\n          ret.dep[key] = \"common\"; // all entries have same value\n        } else {\n          ret.dep[key] = \"dependent\"; // entries depend on values\n        }\n      } else {\n        ret.dep[key] = \"unknown\"; // not found in database\n      }\n    }\n\n    ;\n    ret.intprt = this.getInterpretation(state, keys, ret.dep); //if(this.debug){console.log(\"getDependancy Done:\",JSON.stringify(ret));};\n\n    return ret;\n  };\n\n  this.getInterpretation = function (state, keys, dep) {\n    var key;\n    var interpretation = {};\n    var slen = keys.length;\n\n    for (var kk = 0; kk < slen; kk++) {\n      var kkey = keys[kk];\n      interpretation[kkey] = \"control\";\n    }\n\n    ;\n\n    for (var jj = 0; jj < slen; jj++) {\n      key = keys[jj];\n\n      if (dep[key] === \"unique\") {\n        // \"unique\" keys depend on the other keys...\n        for (var rr = 0; rr < slen; rr++) {\n          var rkey = keys[rr];\n\n          if (dep[rkey] === \"unique\") {\n            // do not remove every \"unique\" key\n            if (rr > jj) {\n              interpretation[rkey] = \"redundant\"; // later control variables are redundant\n            }\n\n            ;\n          } else {\n            // remove all other variables\n            if (rr !== jj) {\n              if (dep[rkey] === \"common\") {\n                interpretation[rkey] = \"redundant\"; // \n              } else {\n                interpretation[rkey] = \"insignificant\"; //\n              }\n\n              ;\n            }\n\n            ;\n          }\n        }\n      }\n    }\n\n    var cnt = 0;\n\n    for (var ll = slen - 1; ll >= 0; ll--) {\n      key = keys[ll];\n\n      if (dep[key] === \"common\") {\n        // common keys have only one value\n        cnt = cnt + 1;\n\n        if (cnt < slen) {\n          // leave at least one redundant variable\n          interpretation[key] = \"redundant\";\n        }\n      }\n    }\n\n    ;\n    return interpretation;\n  };\n}\n\n;\nexport default Auto;","map":{"version":3,"sources":["/home/franktt/react/varseltavle/src/lib/AutoLib.js"],"names":["Auto","debug","complete","toggle","state","console","log","Show","showConfig","selectTableKey","key","keyval","keywhere","keycnt","JSON","stringify","Path","keys","ret","sid","other","indexOf","rest","lenk","length","colkey","getColKey","rowkey","getRowKey","undefined","tableKeyToPath","moveOther2Table","duplicateTableKey","exportAllKeys","lens","jj","jkey","jkeyval","jkeywhere","analysis","analyse","tblkey","sel","val","othkey","concat","Utils","clean","trgkey","trgwhere","where","Database","getWhere","addWhere","ii","testkey","othtable","othdep","getDependancy","intprt","push","testval","dep","hits","maxhits","docs","getDocsCnt","slen","dlen","doc","kk","getInterpretation","interpretation","kkey","rr","rkey","cnt","ll"],"mappings":"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","sourcesContent":["//console.log(\"Loading AutoLib.js\");\n\nfunction Auto() {\n    this.debug=false;\n    this.complete=true;\n    this.toggle=function(state) {\n\tconsole.log(\"Pressed toggle\");\n\tstate.Auto.complete=!state.Auto.complete;\n\tstate.Show.showConfig(state);\n    };\n    // select given table key...\n    this.selectTableKey=function(state,key,keyval,keywhere,keycnt) { // keep abscissa\n\tif(this.debug){console.log(\"selectTableKey Entering:\",key,keyval,keywhere,keycnt,JSON.stringify(state.Path.keys));};\n\tvar ret=false;\n\tvar sid = state.Path.keys.other.indexOf(key);\n\t//console.log(\"SelectTableKey:\",key,sid,JSON.stringify(state.Path.keys.other));\n\tif (sid !== -1 && key !== \"\") { // key is selectable, but maybe not in table...\n\t    // why do you need duplicates of the target key (that will be removed)? \n\t    // - to check if the new selection makes your table keys redundant...\n\t    // You need to check the table keys again. \n\t    // We duplicate the target key into the table array and then remove both copies. \n\t    // This brings the old table keys back again, making them subject to a redundancy check.\n\t    var keys=state.Path.other.rest;\n\t    var lenk=keys.length;\n\t    var colkey=state.Path.getColKey(state);\n\t    var rowkey=state.Path.getRowKey(state);\n\t    if(this.debug){console.log(\"Autopath or not?:\",lenk,colkey,rowkey,sid,state.Auto.complete);};\n\t    if (lenk===0 || colkey===undefined || rowkey===undefined || ! state.Auto.complete ) { // nothing to consider\n\t\tret = state.Path.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t    } else {\n\t\tstate.Path.moveOther2Table(state,key);   // move target key to front of array\n\t\tstate.Path.duplicateTableKey(state,key); // make duplicate\n\t\tstate.Path.exportAllKeys(state);\n\t\t//if(this.debug){console.log(\"Before:\",JSON.stringify(state.Path.keys));};\n\t\tret = state.Auto.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t\tstate.Path.exportAllKeys(state);\n\t\tret = state.Auto.tableKeyToPath(state,key,keyval,keywhere,keycnt); // remove duplicate\n\t    }\n\t};\n\tif (ret) {state.Path.exportAllKeys(state);};\n\tif(this.debug){console.log(\"selectTableKey Done:\",JSON.stringify(state.Path.keys),JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.tableKeyToPath=function (state,key,keyval,keywhere,keycnt) {\n\t//if(this.debug){console.log(\"tableKeyToPath Entering:\",key,keyval,keywhere,keycnt);};\n\t// look for table-key candidates in the rest-stack\n\tvar ret, lens, jj, jkey, jkeyval, jkeywhere;\n\tvar analysis=this.analyse(state,key,keywhere);\n\t// move the key\n\tret=state.Path.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\tif(this.debug){console.log(\"Analysis:\",JSON.stringify(analysis));};\n\tif (analysis.tblkey !== \"\") {  // we found a new table key\n\t    lens=analysis.sel.length;\n\t    for (jj=0;jj<lens;jj++) {\n\t\tjkey=analysis.sel[jj];\n\t\tjkeyval=analysis.val[jj];\n\t\tjkeywhere=jkey + \"='\" + jkeyval+\"'\";\n\t\tstate.Path.tableKeyToPath(state,jkey,jkeyval,jkeywhere,1);\n\t    }\n\t    state.Path.keys.other=[analysis.othkey,analysis.tblkey].concat(state.Utils.clean(analysis.rest));\n\t} else if (analysis.sel.length > 0 || analysis.rest.length > 0) { // no target\n\t    lens=analysis.sel.length;\n\t    for (jj=0;jj<lens;jj++) {\n\t\tjkey=analysis.sel[jj];\n\t\tjkeyval=analysis.val[jj];\n\t\tjkeywhere=jkey + \"='\" + jkeyval + \"'\";\n\t\tthis.tableKeyToPath(state,jkey,jkeyval,jkeywhere,1);\n\t    }\n\t    state.Path.keys.other=[analysis.othkey,\"\"].concat(state.Utils.clean(analysis.rest));\n\t} else {\n\t    state.Path.keys.other=[analysis.othkey];\n\t}\n\tif(this.debug){console.log(\"tableKeyToPath Path:\",JSON.stringify(state.Path.keys));};\n\tif(this.debug){console.log(\"tableKeyToPath Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.analyse=function(state,trgkey,trgwhere) {\n\t//if(this.debug){console.log(\"analyseOther Entering:\",JSON.stringify(trgkey),trgwhere);};\n\t//other key\n\tvar keys=state.Path.other.rest;\n\tvar where=state.Database.getWhere(state);\n\tvar colkey=state.Path.getColKey(state);\n\tvar rowkey=state.Path.getRowKey(state);\n\tvar othkey=(trgkey===colkey?rowkey:colkey); // the other key\n\tvar sel=[]; // selected\n\tvar val=[]; // values\n\tvar rest=[]; //rest\n\tvar tblkey=\"\"; // target key\n\tvar lenk=keys.length;\n\tvar keywhere=state.Database.addWhere(where,trgwhere);\n\t// redundant keys => selected\n\t// insignificant keys => pushed back\n\t// control keys => used in table\n\tfor (var ii = 0; ii< lenk; ii++) {\n\t    // first key dependencies\n\t    var testkey=keys[ii];\n\t    if(this.debug){console.log(\">>>Checking:\",testkey, \" vs Table:(\",trgkey,\",\",othkey,\") where=\",where,trgwhere);};\n\t    var othtable=[othkey,testkey];\n\t    var othdep=this.getDependancy(state,keywhere,othtable);\n\t    if(this.debug){console.log(\"        Other:   \",othkey,testkey,JSON.stringify(othdep));};\n\t    // in case there are no targets\n\t    if (othdep.intprt[othkey]===\"insignificant\" || othdep.intprt[testkey]===\"insignificant\" || tblkey !== \"\") {    // ignore insignificant testkey\n\t\trest.push(testkey);\n\t\tif(this.debug){console.log(\"****  Postpone:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey);};\n\t    } else if (othdep.intprt[testkey]===\"redundant\") { // select redundant testkey\n\t\tvar testval=othdep.val[testkey];\n\t\tsel.push(testkey);\n\t\tval.push(testval);\n\t\tif(this.debug){console.log(\"****  Select:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey,JSON.stringify(othdep),where);};\n\t    } else { // control key\n\t\ttblkey=testkey;                    // we have found a good candidate\n\t\tif(this.debug){console.log(\"****  Target:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey);};\n\t    }\n\t}\n\t//if(this.debug){console.log(\"Sel/Val:\",JSON.stringify(sel),JSON.stringify(val));};\n\tvar ret={sel:sel,val:val,rest:rest,tblkey:tblkey,othkey:othkey};\n\tif(this.debug){console.log(\"analyse Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    // check if keys are inter-dependent, (\"common\", \"unique\", \"dependent\", \"unknown\") \n    this.getDependancy=function(state,where,keys) {\n\t//if(this.debug){console.log(\"getDependancy Entering:\",where,JSON.stringify(keys));};\n\tvar key;\n\t//var where = state.Database.getWhere(state);\n\tvar ret={dep:{},val:{}};\n\tvar hits={};\n\tvar maxhits={};\n\tvar docs=state.Database.getDocsCnt(state,where,keys); // current table keys\n\t//if(this.debug){console.log(\"getDependancy:\",JSON.strings(docs));};\n\tvar slen=keys.length;\n\tvar dlen = docs.length;\n\tfor (var ii = 0; ii < dlen; ii++) {\n    \t    var doc=docs[ii];\n\t    for (var jj=0;jj<slen;jj++) {\n\t\tkey=keys[jj];\n\t\tif (doc[key] !== undefined) {\n\t\t    var val=doc[key];\n\t\t    ret.val[key]=val;\n\t\t    if (hits[key]  === undefined) {hits[key]={};}\n\t\t    hits[key][val] = 1+ (hits[key][val]||0);\n\t\t    if (hits[key][val] > (maxhits[key]||0)) {\n\t\t\tmaxhits[key]=hits[key][val];\n\t\t    }\n\t\t};\n\t    }\n\t};\n\t//if(this.debug){console.log(\"Hits:\",dlen,JSON.stringify(hits),where);};\n\tfor (var kk=0;kk<slen;kk++) {\n\t    key=keys[kk];\n\t    if (maxhits[key] !== undefined) {\n\t\tif (maxhits[key]  === 1) {          // every entry has unique value\n\t\t    ret.dep[key]=\"unique\";\n\t\t} else if (maxhits[key]  === dlen) {\n\t\t    ret.dep[key]=\"common\";    // all entries have same value\n\t\t} else {\n\t\t    ret.dep[key]=\"dependent\";    // entries depend on values\n\t\t}\n\t    } else {\n\t\tret.dep[key]=\"unknown\"; // not found in database\n\t    }\n\t};\n\tret.intprt=this.getInterpretation(state,keys,ret.dep);\n\t//if(this.debug){console.log(\"getDependancy Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.getInterpretation=function(state,keys,dep){\n\tvar key;\n\tvar interpretation={};\n\tvar slen=keys.length;\n\tfor (var kk=0;kk<slen;kk++) {\n\t    var kkey=keys[kk];\n\t    interpretation[kkey]=\"control\";\n\t};\n\tfor (var jj=0;jj<slen;jj++) {\n\t    key=keys[jj];\n\t    if (dep[key]  === \"unique\") {// \"unique\" keys depend on the other keys...\n\t\tfor (var rr=0;rr<slen;rr++) {\n\t\t    var rkey=keys[rr];\n\t\t    if (dep[rkey] === \"unique\") { // do not remove every \"unique\" key\n\t\t\tif (rr > jj) {\n\t\t\t    interpretation[rkey]=\"redundant\"; // later control variables are redundant\n\t\t\t};\n\t\t    } else { // remove all other variables\n\t\t\tif (rr !== jj) {\n\t\t\t    if (dep[rkey] === \"common\") {\n\t\t\t\tinterpretation[rkey]=\"redundant\"; // \n\t\t\t    } else {\n\t\t\t\tinterpretation[rkey]=\"insignificant\"; //\n\t\t\t    };\n\t\t\t};\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tvar cnt=0;\n\tfor (var ll=slen-1;ll>=0;ll--) {\n\t    key=keys[ll];\n\t    if (dep[key]  === \"common\") { // common keys have only one value\n\t\tcnt=cnt+1;\n\t\tif (cnt < slen) { // leave at least one redundant variable\n\t\t    interpretation[key]=\"redundant\";\n\t\t}\n\t    }\n\t};\n\treturn interpretation;\n    };\n};\nexport default Auto;\n"]},"metadata":{},"sourceType":"module"}