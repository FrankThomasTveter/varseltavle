{"ast":null,"code":"import _toConsumableArray from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/franktt/react/varseltavle/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/* eslint-disable react/prop-types */\n\n/* eslint-disable import/no-unresolved */\nimport React, { Component } from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { withSnackbar } from 'notistack';\nimport { removeSnackbar } from './redux/actions';\n\nvar Notifier =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Notifier, _Component);\n\n  function Notifier() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Notifier);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Notifier)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.displayed = [];\n\n    _this.storeDisplayed = function (id) {\n      _this.displayed = [].concat(_toConsumableArray(_this.displayed), [id]);\n    };\n\n    return _this;\n  }\n\n  _createClass(Notifier, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(_ref) {\n      var _ref$notifications = _ref.notifications,\n          newSnacks = _ref$notifications === void 0 ? [] : _ref$notifications;\n      var currentSnacks = this.props.notifications;\n      var notExists = false;\n\n      var _loop = function _loop(i) {\n        if (notExists) return \"continue\";\n        notExists = notExists || !currentSnacks.filter(function (_ref2) {\n          var key = _ref2.key;\n          return newSnacks[i].key === key;\n        }).length;\n      };\n\n      for (var i = 0; i < newSnacks.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return notExists;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var _this$props$notificat = this.props.notifications,\n          notifications = _this$props$notificat === void 0 ? [] : _this$props$notificat;\n      notifications.forEach(function (notification) {\n        // Do nothing if snackbar is already displayed\n        if (_this2.displayed.includes(notification.key)) return; // Display snackbar using notistack\n\n        _this2.props.enqueueSnackbar(notification.message, notification.options); // Keep track of snackbars that we've displayed\n\n\n        _this2.storeDisplayed(notification.key); // Dispatch action to remove snackbar from redux store\n\n\n        _this2.props.removeSnackbar(notification.key);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return Notifier;\n}(Component);\n\nvar mapStateToProps = function mapStateToProps(store) {\n  return {\n    notifications: store.app.notifications\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return bindActionCreators({\n    removeSnackbar: removeSnackbar\n  }, dispatch);\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(withSnackbar(Notifier));","map":{"version":3,"sources":["/home/franktt/react/varseltavle/src/react/Notifier.js"],"names":["React","Component","bindActionCreators","connect","withSnackbar","removeSnackbar","Notifier","displayed","storeDisplayed","id","notifications","newSnacks","currentSnacks","props","notExists","i","filter","key","length","forEach","notification","includes","enqueueSnackbar","message","options","mapStateToProps","store","app","mapDispatchToProps","dispatch"],"mappings":";;;;;;;AACA;;AACA;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,kBAAT,QAAmC,OAAnC;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,YAAT,QAA6B,WAA7B;AACA,SAASC,cAAT,QAA+B,iBAA/B;;IAEMC,Q;;;;;;;;;;;;;;;;;UACFC,S,GAAY,E;;UAEZC,c,GAAiB,UAACC,EAAD,EAAQ;AACrB,YAAKF,SAAL,gCAAqB,MAAKA,SAA1B,IAAqCE,EAArC;AACH,K;;;;;;;gDAEwD;AAAA,oCAAjCC,aAAiC;AAAA,UAAlBC,SAAkB,mCAAN,EAAM;AAAA,UAC9BC,aAD8B,GACZ,KAAKC,KADO,CAC7CH,aAD6C;AAErD,UAAII,SAAS,GAAG,KAAhB;;AAFqD,iCAG5CC,CAH4C;AAIjD,YAAID,SAAJ,EAAe;AACfA,QAAAA,SAAS,GAAGA,SAAS,IAAI,CAACF,aAAa,CAACI,MAAd,CAAqB;AAAA,cAAGC,GAAH,SAAGA,GAAH;AAAA,iBAAaN,SAAS,CAACI,CAAD,CAAT,CAAaE,GAAb,KAAqBA,GAAlC;AAAA,SAArB,EAA4DC,MAAtF;AALiD;;AAGrD,WAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACO,MAA9B,EAAsCH,CAAC,IAAI,CAA3C,EAA8C;AAAA,yBAArCA,CAAqC;;AAAA,iCAC3B;AAElB;;AACD,aAAOD,SAAP;AACH;;;yCAEoB;AAAA;;AAAA,kCACc,KAAKD,KADnB,CACTH,aADS;AAAA,UACTA,aADS,sCACO,EADP;AAGjBA,MAAAA,aAAa,CAACS,OAAd,CAAsB,UAACC,YAAD,EAAkB;AACpC;AACA,YAAI,MAAI,CAACb,SAAL,CAAec,QAAf,CAAwBD,YAAY,CAACH,GAArC,CAAJ,EAA+C,OAFX,CAGpC;;AACA,QAAA,MAAI,CAACJ,KAAL,CAAWS,eAAX,CAA2BF,YAAY,CAACG,OAAxC,EAAiDH,YAAY,CAACI,OAA9D,EAJoC,CAKpC;;;AACA,QAAA,MAAI,CAAChB,cAAL,CAAoBY,YAAY,CAACH,GAAjC,EANoC,CAOpC;;;AACA,QAAA,MAAI,CAACJ,KAAL,CAAWR,cAAX,CAA0Be,YAAY,CAACH,GAAvC;AACH,OATD;AAUH;;;6BAEQ;AACL,aAAO,IAAP;AACH;;;;EAlCkBhB,S;;AAqCvB,IAAMwB,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,KAAK;AAAA,SAAK;AAC9BhB,IAAAA,aAAa,EAAEgB,KAAK,CAACC,GAAN,CAAUjB;AADK,GAAL;AAAA,CAA7B;;AAIA,IAAMkB,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAC,QAAQ;AAAA,SAAI3B,kBAAkB,CAAC;AAAEG,IAAAA,cAAc,EAAdA;AAAF,GAAD,EAAqBwB,QAArB,CAAtB;AAAA,CAAnC;;AAEA,eAAe1B,OAAO,CAClBsB,eADkB,EAElBG,kBAFkB,CAAP,CAGbxB,YAAY,CAACE,QAAD,CAHC,CAAf","sourcesContent":["\n/* eslint-disable react/prop-types */\n/* eslint-disable import/no-unresolved */\nimport React, { Component } from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { withSnackbar } from 'notistack';\nimport { removeSnackbar } from './redux/actions';\n\nclass Notifier extends Component {\n    displayed = [];\n\n    storeDisplayed = (id) => {\n        this.displayed = [...this.displayed, id];\n    };\n\n    shouldComponentUpdate({ notifications: newSnacks = [] }) {\n        const { notifications: currentSnacks } = this.props;\n        let notExists = false;\n        for (let i = 0; i < newSnacks.length; i += 1) {\n            if (notExists) continue;\n            notExists = notExists || !currentSnacks.filter(({ key }) => newSnacks[i].key === key).length;\n        }\n        return notExists;\n    }\n\n    componentDidUpdate() {\n        const { notifications = [] } = this.props;\n\n        notifications.forEach((notification) => {\n            // Do nothing if snackbar is already displayed\n            if (this.displayed.includes(notification.key)) return;\n            // Display snackbar using notistack\n            this.props.enqueueSnackbar(notification.message, notification.options);\n            // Keep track of snackbars that we've displayed\n            this.storeDisplayed(notification.key);\n            // Dispatch action to remove snackbar from redux store\n            this.props.removeSnackbar(notification.key);\n        });\n    }\n\n    render() {\n        return null;\n    }\n}\n\nconst mapStateToProps = store => ({\n    notifications: store.app.notifications,\n});\n\nconst mapDispatchToProps = dispatch => bindActionCreators({ removeSnackbar }, dispatch);\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps,\n)(withSnackbar(Notifier));\n"]},"metadata":{},"sourceType":"module"}