{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', 'react', 'prop-types', './Table', './Row', './Cell'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('react'), require('prop-types'), require('./Table'), require('./Row'), require('./Cell'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.react, global.propTypes, global.Table, global.Row, global.Cell);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _react, _propTypes, _Table, _Row, _Cell) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Cell = exports.Row = exports.Table = exports.StickyTable = undefined;\n\n  var _react2 = _interopRequireDefault(_react);\n\n  var _propTypes2 = _interopRequireDefault(_propTypes);\n\n  var _Table2 = _interopRequireDefault(_Table);\n\n  var _Row2 = _interopRequireDefault(_Row);\n\n  var _Cell2 = _interopRequireDefault(_Cell);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var StickyTable = function (_PureComponent) {\n    _inherits(StickyTable, _PureComponent);\n\n    function StickyTable(props) {\n      _classCallCheck(this, StickyTable);\n\n      var _this = _possibleConstructorReturn(this, (StickyTable.__proto__ || Object.getPrototypeOf(StickyTable)).call(this, props));\n\n      _this.rowCount = 0;\n      _this.columnCount = 0;\n      _this.xScrollSize = 0;\n      _this.yScrollSize = 0;\n      _this.dom = {};\n      _this.stickyHeaderCount = props.stickyHeaderCount === 0 ? 0 : _this.stickyHeaderCount || 1;\n      _this.isFirefox = navigator && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n      ['onScrollX', 'onScrollBarX', 'onScrollBarY', 'scrollXScrollbar', 'scrollYScrollbar', 'considerResizing'].forEach(function (fn) {\n        _this[fn] = _this[fn].bind(_this);\n      });\n      return _this;\n    }\n    /**\n     * @returns {undefined}\n     */\n\n\n    _createClass(StickyTable, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        if (this.dom.wrapper) {\n          this.dom.bodyTable = this.dom.wrapper.querySelector('.sticky-table-x-wrapper .sticky-table-table');\n          this.dom.xScrollbar = this.dom.wrapper.querySelector('.x-scrollbar');\n          this.dom.yScrollbar = this.dom.wrapper.querySelector('.y-scrollbar');\n          this.dom.xWrapper = this.dom.wrapper.querySelector('.sticky-table-x-wrapper');\n          this.dom.yWrapper = this.dom.wrapper.querySelector('.sticky-table-y-wrapper');\n          this.dom.stickyHeader = this.dom.wrapper.querySelector('.sticky-table-header');\n          this.dom.stickyColumn = this.dom.wrapper.querySelector('.sticky-table-column');\n          this.dom.stickyCorner = this.dom.wrapper.querySelector('.sticky-table-corner');\n          this.dom.stickyHeaderTable = this.dom.stickyHeader.querySelector('.sticky-table-table');\n          this.dom.stickyColumnTable = this.dom.stickyColumn.querySelector('.sticky-table-table');\n          this.dom.stickyCornerTable = this.dom.stickyCorner.querySelector('.sticky-table-table');\n          this.setScrollData();\n          this.considerResizing();\n          setTimeout(function () {\n            return _this2.considerResizing();\n          });\n          this.resizeInterval = setInterval(this.considerResizing, 60); //X Scrollbars\n\n          this.dom.xWrapper.addEventListener('scroll', this.onScrollX);\n          this.dom.xWrapper.addEventListener('scroll', this.scrollXScrollbar);\n          this.dom.xScrollbar.addEventListener('scroll', this.onScrollBarX); //Y Scrollbars\n\n          this.dom.yWrapper.addEventListener('scroll', this.scrollYScrollbar);\n          this.dom.yScrollbar.addEventListener('scroll', this.onScrollBarY);\n        }\n      }\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate() {\n        this.considerResizing();\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (this.dom.wrapper) {\n          this.dom.xWrapper.removeEventListener('scroll', this.onScrollX);\n          this.dom.xWrapper.removeEventListener('scroll', this.scrollXScrollbar);\n          this.dom.xScrollbar.removeEventListener('scroll', this.onScrollBarX);\n          this.dom.yWrapper.removeEventListener('scroll', this.scrollYScrollbar);\n          this.dom.yScrollbar.removeEventListener('scroll', this.onScrollBarY);\n          clearInterval(this.resizeInterval);\n        }\n      }\n    }, {\n      key: 'setScrollData',\n      value: function setScrollData() {\n        this.suppressScrollX = false;\n        this.suppressScrollY = false;\n        return this.scrollData = {\n          scrollTop: this.dom.yScrollbar.scrollTop,\n          scrollHeight: this.dom.yScrollbar.scrollHeight,\n          clientHeight: this.dom.yScrollbar.clientHeight,\n          scrollLeft: this.dom.xScrollbar.scrollLeft,\n          scrollWidth: this.dom.xScrollbar.scrollWidth,\n          clientWidth: this.dom.xScrollbar.clientWidth\n        };\n      }\n    }, {\n      key: 'onScrollBarX',\n      value: function onScrollBarX() {\n        if (!this.suppressScrollX) {\n          this.scrollData.scrollLeft = this.dom.xWrapper.scrollLeft = this.dom.xScrollbar.scrollLeft;\n          this.suppressScrollX = true;\n        } else {\n          this.handleScroll();\n          this.suppressScrollX = false;\n        }\n      }\n    }, {\n      key: 'onScrollBarY',\n      value: function onScrollBarY() {\n        if (!this.suppressScrollY) {\n          this.scrollData.scrollTop = this.dom.yWrapper.scrollTop = this.dom.yScrollbar.scrollTop;\n          this.suppressScrollY = true;\n        } else {\n          this.handleScroll();\n          this.suppressScrollY = false;\n        }\n      }\n    }, {\n      key: 'onScrollX',\n      value: function onScrollX() {\n        var scrollLeft = Math.max(this.dom.xWrapper.scrollLeft, 0);\n        this.dom.stickyHeaderTable.style.transform = 'translate(' + -1 * scrollLeft + 'px, 0) translateZ(0)';\n      }\n    }, {\n      key: 'scrollXScrollbar',\n      value: function scrollXScrollbar() {\n        if (!this.suppressScrollX) {\n          this.scrollData.scrollLeft = this.dom.xScrollbar.scrollLeft = this.dom.xWrapper.scrollLeft;\n          this.suppressScrollX = true;\n        } else {\n          this.handleScroll();\n          this.suppressScrollX = false;\n        }\n      }\n    }, {\n      key: 'scrollYScrollbar',\n      value: function scrollYScrollbar() {\n        if (!this.suppressScrollY) {\n          this.scrollData.scrollTop = this.dom.yScrollbar.scrollTop = this.dom.yWrapper.scrollTop;\n          this.suppressScrollY = true;\n        } else {\n          this.handleScroll();\n          this.suppressScrollY = false;\n        }\n      }\n    }, {\n      key: 'handleScroll',\n      value: function handleScroll() {\n        if (this.props.onScroll) {\n          this.props.onScroll(this.scrollData);\n        }\n      }\n    }, {\n      key: 'considerResizing',\n      value: function considerResizing() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$forceCellTableRe = _ref.forceCellTableResize,\n            forceCellTableResize = _ref$forceCellTableRe === undefined ? false : _ref$forceCellTableRe,\n            _ref$forceWrapperResi = _ref.forceWrapperResize,\n            forceWrapperResize = _ref$forceWrapperResi === undefined ? false : _ref$forceWrapperResi;\n\n        var wrapperSize = {\n          width: this.dom.wrapper.offsetWidth,\n          height: this.dom.wrapper.offsetWidth\n        };\n        var tableCellSizes = {\n          corner: {\n            width: this.dom.stickyCornerTable.offsetWidth,\n            height: this.dom.stickyCornerTable.offsetHeight\n          },\n          header: {\n            width: this.dom.stickyHeaderTable.offsetWidth,\n            height: this.dom.stickyHeaderTable.offsetHeight\n          },\n          column: {\n            width: this.dom.stickyColumnTable.offsetWidth,\n            height: this.dom.stickyColumnTable.offsetHeight\n          },\n          body: {\n            width: this.dom.bodyTable.offsetWidth,\n            height: this.dom.bodyTable.offsetHeight\n          }\n        };\n        var tableCellSizesChanged = JSON.stringify(tableCellSizes) !== JSON.stringify(this.oldTableCellSizes);\n        var wrapperSizeChanged = JSON.stringify(wrapperSize) !== JSON.stringify(this.oldWrapperSize);\n\n        if (forceCellTableResize || !this.oldTableCellSizes || tableCellSizesChanged) {\n          this.setRowHeights();\n          this.setColumnWidths();\n          this.oldTableCellSizes = tableCellSizes;\n        }\n\n        if (forceWrapperResize || !this.oldWrapperSize || wrapperSizeChanged || tableCellSizesChanged) {\n          this.setScrollBarDims();\n          this.setScrollBarWrapperDims();\n          this.setScrollData();\n          this.handleScroll();\n          this.dom.xWrapper.style.maxWidth = 'calc(100% - ' + this.dom.stickyColumn.offsetWidth + 'px';\n          this.dom.yWrapper.style.height = 'calc(100% - ' + this.dom.stickyHeader.offsetHeight + 'px';\n          this.oldWrapperSize = wrapperSize;\n        }\n      }\n    }, {\n      key: 'setScrollBarPaddings',\n      value: function setScrollBarPaddings() {\n        var scrollPadding = '0px 0px ' + this.xScrollSize + 'px 0px';\n        this.dom.wrapper.style.padding = scrollPadding;\n        var scrollPadding = '0px ' + this.yScrollSize + 'px 0px 0px';\n        this.dom.xWrapper.firstChild.style.padding = scrollPadding;\n      }\n    }, {\n      key: 'setScrollBarWrapperDims',\n      value: function setScrollBarWrapperDims() {\n        this.dom.yScrollbar.style.height = 'calc(100% - ' + this.dom.stickyHeader.offsetHeight + 'px)';\n        this.dom.yScrollbar.style.top = this.dom.stickyHeader.offsetHeight + 'px';\n      }\n    }, {\n      key: 'setScrollBarDims',\n      value: function setScrollBarDims() {\n        var width = this.getNodeSize(this.dom.bodyTable.firstChild).width + this.dom.stickyColumn.offsetWidth;\n        this.dom.xScrollbar.firstChild.style.width = width + 'px';\n        this.xScrollSize = this.dom.xScrollbar.offsetHeight - this.dom.xScrollbar.clientHeight;\n        var height = this.dom.bodyTable.offsetHeight + this.dom.stickyHeader.offsetHeight;\n        this.dom.yScrollbar.firstChild.style.height = height + 'px';\n        this.yScrollSize = this.dom.yScrollbar.offsetWidth - this.dom.yScrollbar.clientWidth;\n\n        if (!this.isFirefox) {\n          this.setScrollBarPaddings();\n        }\n\n        if (this.xScrollSize) this.dom.xScrollbar.style.height = this.xScrollSize + 1 + 'px';\n        if (this.yScrollSize) this.dom.yScrollbar.style.width = this.yScrollSize + 1 + 'px';\n      }\n    }, {\n      key: 'setRowHeights',\n      value: function setRowHeights() {\n        var _this3 = this;\n\n        var bodyRows, stickyHeaderRows, stickyCornerRows, stickyColumnRows, cells, columnHeight, resizeRow, row;\n\n        if (this.rowCount > 0 && this.props.stickyColumnCount > 0) {\n          bodyRows = this.dom.bodyTable.childNodes;\n          stickyColumnRows = this.dom.stickyColumnTable.childNodes;\n          stickyCornerRows = this.dom.stickyCornerTable.childNodes;\n          stickyHeaderRows = this.dom.stickyHeaderTable.childNodes;\n\n          resizeRow = function resizeRow(row) {\n            cells = [];\n\n            if (row < _this3.props.stickyHeaderCount) {\n              //It's a sticky column\n              cells[0] = stickyCornerRows[row].childNodes[0];\n              cells[1] = stickyHeaderRows[row].childNodes[0];\n            } else {\n              //It's a body column\n              cells[0] = stickyColumnRows[row - _this3.props.stickyHeaderCount].childNodes[0];\n              cells[1] = bodyRows[row - _this3.props.stickyHeaderCount].childNodes[0];\n            }\n\n            cells.forEach(function (cell) {\n              return cell.style.height = '';\n            });\n            columnHeight = Math.max(_this3.getNodeSize(cells[0]).height, _this3.getNodeSize(cells[1]).height);\n            cells.forEach(function (cell) {\n              return cell.style.height = Math.round(columnHeight) + 'px';\n            });\n          };\n\n          for (row = 0; row < this.rowCount; row++) {\n            setTimeout(resizeRow(row));\n          }\n        }\n      }\n    }, {\n      key: 'setColumnWidths',\n      value: function setColumnWidths() {\n        var _this4 = this;\n\n        var firstBodyRowCells, firstStickyHeaderRowCells, firstStickyCornerRowCells, firstStickyColumnRowCells, cells, resizeColumn, column;\n\n        if (this.columnCount > 0 && this.props.stickyHeaderCount > 0) {\n          firstBodyRowCells = this.dom.bodyTable.childNodes[0].childNodes;\n          firstStickyHeaderRowCells = this.dom.stickyHeaderTable.childNodes[0].childNodes;\n          firstStickyCornerRowCells = this.dom.stickyCornerTable.childNodes[0].childNodes;\n          firstStickyColumnRowCells = this.dom.stickyColumnTable.childNodes[0].childNodes;\n\n          resizeColumn = function resizeColumn(column) {\n            cells = [];\n\n            if (column < _this4.props.stickyColumnCount) {\n              //It's a sticky column\n              cells[0] = firstStickyColumnRowCells[column];\n              cells[1] = firstStickyCornerRowCells[column];\n            } else {\n              //It's a body column\n              cells[0] = firstBodyRowCells[column - _this4.props.stickyColumnCount];\n              cells[1] = firstStickyHeaderRowCells[column - _this4.props.stickyColumnCount];\n            } //IMPORTANT: minWidth is a necessary property here\n            //because display: table-cell desparately wants to be dynamic/minimum in size\n\n\n            cells.forEach(function (cell) {\n              return cell.style.width = cell.style.minWidth = '';\n            });\n            var columnWidth = Math.max(_this4.getNodeSize(cells[0]).width, _this4.getNodeSize(cells[1]).width);\n            cells.forEach(function (cell) {\n              return cell.style.width = cell.style.minWidth = columnWidth + 'px';\n            });\n          };\n\n          for (column = 0; column < this.columnCount; column++) {\n            setTimeout(resizeColumn(column));\n          }\n        }\n      }\n    }, {\n      key: 'getNodeSize',\n      value: function getNodeSize(node) {\n        return node.getBoundingClientRect();\n      }\n    }, {\n      key: 'getStickyColumnRows',\n      value: function getStickyColumnRows(rows) {\n        var _this5 = this;\n\n        return this.getRowSubset(rows, function (r) {\n          return r >= _this5.props.stickyHeaderCount;\n        }, function (c) {\n          return c < _this5.props.stickyColumnCount;\n        });\n      }\n    }, {\n      key: 'getStickyHeaderRows',\n      value: function getStickyHeaderRows(rows) {\n        var _this6 = this;\n\n        return this.getRowSubset(rows, function (r) {\n          return r < _this6.props.stickyHeaderCount;\n        }, function (c) {\n          return c >= _this6.props.stickyColumnCount;\n        });\n      }\n    }, {\n      key: 'getStickyCornerRows',\n      value: function getStickyCornerRows(rows) {\n        var _this7 = this;\n\n        return this.getRowSubset(rows, function (r) {\n          return r < _this7.props.stickyHeaderCount;\n        }, function (c) {\n          return c < _this7.props.stickyColumnCount;\n        });\n      }\n    }, {\n      key: 'getBodyRows',\n      value: function getBodyRows(rows) {\n        var _this8 = this;\n\n        return this.getRowSubset(rows, function (r) {\n          return r >= _this8.props.stickyHeaderCount;\n        }, function (c) {\n          return c >= _this8.props.stickyColumnCount;\n        });\n      }\n    }, {\n      key: 'getRowSubset',\n      value: function getRowSubset(rows, includeRow, includeColumn) {\n        var stickyRows = [],\n            cells,\n            cellsSubset;\n        rows.forEach(function (row, r) {\n          if (includeRow(r)) {\n            cells = _react2.default.Children.toArray(row.props.children);\n            cellsSubset = [];\n            cells.forEach(function (cell, c) {\n              if (includeColumn(c)) {\n                cellsSubset.push(cell);\n              }\n            });\n            stickyRows.push(_react2.default.createElement(_Row2.default, _extends({}, row.props, {\n              id: '',\n              key: r\n            }), cellsSubset));\n          }\n        });\n        return stickyRows;\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this9 = this; //This is probably sub-optimal because render only needs\n        //to be called for react components that are sub-classed\n        //and don't have props.children that are <Cell>s\n\n\n        var rows = _react2.default.Children.toArray(this.props.children).map(function (row) {\n          return new row.type(row.props).render(); // eslint-disable-line new-cap\n        });\n\n        var stickyCornerRows = this.getStickyCornerRows(rows);\n        var stickyColumnRows = this.getStickyColumnRows(rows);\n        var stickyHeaderRows = this.getStickyHeaderRows(rows);\n        var bodyRows = this.getBodyRows(rows);\n        this.rowCount = rows.length;\n        this.columnCount = rows[0] && _react2.default.Children.toArray(rows[0].props.children).length || 0;\n\n        var setWrapperElement = function setWrapperElement(element) {\n          if (element) _this9.dom.wrapper = element;\n        };\n\n        return _react2.default.createElement('div', {\n          className: 'sticky-table ' + (this.props.className || ''),\n          ref: setWrapperElement\n        }, _react2.default.createElement('div', {\n          className: 'x-scrollbar'\n        }, _react2.default.createElement('div', null)), _react2.default.createElement('div', {\n          className: 'y-scrollbar'\n        }, _react2.default.createElement('div', null)), _react2.default.createElement('div', {\n          className: 'sticky-table-header-wrapper'\n        }, _react2.default.createElement('div', {\n          className: ['sticky-table-corner', this.props.stickyHeaderCount && this.props.stickyColumnCount ? '' : 'hidden'].join(' ')\n        }, _react2.default.createElement(_Table2.default, null, stickyCornerRows)), _react2.default.createElement('div', {\n          className: ['sticky-table-header', this.props.stickyHeaderCount ? '' : 'hidden'].join(' ')\n        }, _react2.default.createElement(_Table2.default, null, stickyHeaderRows))), _react2.default.createElement('div', {\n          className: 'sticky-table-y-wrapper'\n        }, _react2.default.createElement('div', {\n          className: ['sticky-table-column', this.props.stickyColumnCount ? '' : 'hidden'].join(' ')\n        }, _react2.default.createElement(_Table2.default, null, stickyColumnRows)), _react2.default.createElement('div', {\n          className: 'sticky-table-x-wrapper'\n        }, _react2.default.createElement(_Table2.default, null, bodyRows))));\n      }\n    }]);\n\n    return StickyTable;\n  }(_react.PureComponent);\n\n  StickyTable.propTypes = {\n    stickyHeaderCount: _propTypes2.default.number,\n    stickyColumnCount: _propTypes2.default.number,\n    onScroll: _propTypes2.default.func\n  };\n  StickyTable.defaultProps = {\n    stickyHeaderCount: 1,\n    stickyColumnCount: 1\n  };\n  exports.StickyTable = StickyTable;\n  exports.Table = _Table2.default;\n  exports.Row = _Row2.default;\n  exports.Cell = _Cell2.default;\n});","map":null,"metadata":{},"sourceType":"script"}