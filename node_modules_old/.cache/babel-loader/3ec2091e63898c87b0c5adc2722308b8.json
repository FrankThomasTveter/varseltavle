{"ast":null,"code":"//console.log(\"Loading AutoLib.js\");\nfunction Auto() {\n  this.debug = false;\n  this.complete = true;\n\n  this.toggle = function (state) {\n    console.log(\"Pressed toggle\");\n    state.Auto.complete = !state.Auto.complete;\n\n    if (!state.Auto.complete) {\n      state.Path.tkeys = 2;\n    }\n\n    state.Show.showConfig(state);\n  }; // re-arrange path...\n\n\n  this.setKeyNumber = function (state) {\n    state.Path.tkeys = 2;\n\n    if (state.Auto.complete) {\n      // test 2 keys...\n      state.Path.exportAllKeys(state);\n      var first = state.Path.getFirstKey(state);\n      var second = state.Path.getSecondKey(state);\n      var where = state.Database.getWhere(state);\n      var othdep = this.getDependancy(state, where, state.Path.other.table); // check if keys are inter-dependent...\n\n      if (othdep.dep[first] === \"dependent\" & othdep.dep[second] === \"unique\" || othdep.dep[first] === \"unique\" & othdep.dep[second] === \"dependent\") {\n        //console.log(\"**** Reordering anyways:\",JSON.stringify(othdep));\n        this.reorderKeys(state);\n      }\n\n      ;\n\n      if (this.debug) {\n        console.log(\"Keys:\", JSON.stringify(state.Path.other.table), JSON.stringify(othdep));\n      }\n    }\n  };\n\n  this.reorderKeys = function (state) {\n    if (this.debug) {\n      console.log(\"############# Reordering keys:\", JSON.stringify(state.Path.keys));\n    }\n\n    if (state.Auto.complete) {\n      state.Path.exportAllKeys(state);\n      var analysis = this.analyse(state);\n      this.applyAnalysis(state, analysis);\n      state.Path.exportAllKeys(state); //console.log(\"############# Reordered keys:\",JSON.stringify(state.Path.keys));\n      //console.log(\"############# Reordered other:\",JSON.stringify(state.Path.other));\n    }\n\n    ;\n  }; // select given table key...\n\n\n  this.selectTableKey = function (state, key, keyval, keywhere, keycnt, keep) {\n    // keep abscissa\n    if (this.debug) {\n      console.log(\"selectTableKey Entering:\", key, keyval, keywhere, keycnt, JSON.stringify(state.Path.keys));\n    }\n\n    ;\n    var ret = false;\n    var sid = state.Path.keys.other.indexOf(key); //console.log(\"SelectTableKey:\",key,sid,JSON.stringify(state.Path.keys.other));\n\n    if (sid !== -1 && key !== \"\") {\n      // key is selectable, but maybe not in table...\n      // why do you need duplicates of the target key (that will be removed)? \n      // - to check if the new selection makes your table keys redundant...\n      // You need to check the table keys again. \n      // We duplicate the target key into the table array and then remove both copies. \n      // This brings the old table keys back again, making them subject to a redundancy check.\n      var keys = state.Path.other.rest;\n      var lenk = keys.length;\n      var colkey = state.Path.getColKey(state);\n      var rowkey = state.Path.getRowKey(state);\n\n      if (this.debug) {\n        console.log(\"Autopath or not?:\", lenk, colkey, rowkey, sid, state.Auto.complete);\n      }\n\n      ;\n\n      if (keep !== undefined & keep) {\n        // only move key, no auto select\n        ret = state.Path.addTableKeyToPath(state, key, keyval, keywhere, keycnt);\n      } else if (lenk === 0 || colkey === undefined || rowkey === undefined || !state.Auto.complete) {\n        // nothing to consider\n        ret = state.Path.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n      } else if (key !== colkey && key !== rowkey) {\n        // plain select...\n        ret = state.Path.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n      } else {\n        // auto-select\n        state.Path.moveOther2Table(state, key); // move target key to front of array\n\n        state.Path.duplicateTableKey(state, key); // make duplicate\n\n        state.Path.exportAllKeys(state); //if(this.debug){console.log(\"Before:\",JSON.stringify(state.Path.keys));};\n\n        ret = state.Auto.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n        state.Path.exportAllKeys(state);\n        ret = state.Auto.tableKeyToPath(state, key, keyval, keywhere, keycnt); // remove duplicate\n      }\n    }\n\n    ;\n\n    if (ret) {\n      state.Path.exportAllKeys(state);\n    }\n\n    ;\n\n    if (this.debug) {\n      console.log(\"selectTableKey Done:\", JSON.stringify(state.Path.keys), JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  };\n\n  this.applyAnalysis = function (state, analysis) {\n    var lens, jj, jkey, jkeyval, jkeywhere;\n    var rest = [];\n    var ignore = state.Path.other.ignore;\n\n    if (analysis.tblkey !== \"\" || analysis.sel.length > 0 || analysis.rest.length > 0) {\n      lens = analysis.sel.length;\n\n      for (jj = 0; jj < lens; jj++) {\n        jkey = analysis.sel[jj];\n        jkeyval = analysis.val[jj];\n        jkeywhere = jkey + \"='\" + jkeyval + \"'\";\n\n        if (jkeyval !== null) {\n          state.Path.tableKeyToPath(state, jkey, jkeyval, jkeywhere, 1);\n        } else {\n          console.log(\"Panick-mode:\", jkey);\n          analysis.rest.push(jkey);\n        }\n      }\n\n      if (this.debug) {\n        console.log(\"tableKeyToPath Init:\", JSON.stringify(state.Path.keys));\n      }\n\n      ;\n      rest = state.Utils.clean(analysis.rest);\n    }\n\n    if (analysis.tblkey !== \"\") {\n      state.Path.tkeys = 2;\n      state.Path.keys.other = state.Utils.clean([analysis.othkey, analysis.tblkey].concat(rest).concat(ignore));\n    } else if (analysis.othkey !== undefined) {\n      state.Path.tkeys = 1;\n      state.Path.keys.other = state.Utils.clean([analysis.othkey].concat(rest).concat(ignore));\n    } else {\n      state.Path.tkeys = 1;\n      state.Path.keys.other = state.Utils.clean([].concat(rest).concat(ignore));\n    }\n\n    ;\n  };\n\n  this.tableKeyToPath = function (state, key, keyval, keywhere, keycnt) {\n    //if(this.debug){console.log(\"tableKeyToPath Entering:\",key,keyval,keywhere,keycnt);};\n    // look for table-key candidates in the rest-stack\n    var analysis = this.analyse(state, key, keywhere); // move the key\n\n    var ret = state.Path.tableKeyToPath(state, key, keyval, keywhere, keycnt);\n    this.applyAnalysis(state, analysis);\n\n    if (this.debug) {\n      console.log(\"Analysis:\", JSON.stringify(analysis));\n    }\n\n    ;\n\n    if (this.debug) {\n      console.log(\"tableKeyToPath Path:\", JSON.stringify(state.Path.keys));\n    }\n\n    ;\n\n    if (this.debug) {\n      console.log(\"tableKeyToPath Done:\", JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  };\n\n  this.analyse = function (state, trgkey, trgwhere) {\n    if (this.debug) {\n      console.log(\"analyseOther Entering:\", JSON.stringify(state.Path.other));\n    }\n\n    ; //other key\n\n    var keys;\n    var where = state.Database.getWhere(state);\n    var othkey;\n    var soft = false;\n\n    if (trgkey === undefined) {\n      soft = true;\n      othkey = state.Path.getFirstKey(state);\n      trgkey = \"\";\n      trgwhere = \"\";\n\n      if (state.Path.tkeys === 2) {\n        keys = [state.Path.getSecondKey(state)].concat(state.Path.other.rest);\n      } else {\n        keys = state.Path.other.rest;\n      }\n\n      ;\n    } else {\n      var colkey = state.Path.getColKey(state);\n      var rowkey = state.Path.getRowKey(state);\n      othkey = trgkey === colkey ? rowkey : colkey; // the other key\n\n      keys = state.Path.other.rest;\n    }\n\n    ;\n    var sel = []; // selected\n\n    var val = []; // values\n\n    var rest = []; //rest\n\n    var tblkey = \"\"; // target key\n\n    var lenk = keys.length;\n    var keywhere = state.Database.addWhere(where, trgwhere); // redundant keys => selected\n    // insignificant keys => pushed back\n    // control keys => used in table\n\n    for (var ii = 0; ii < lenk; ii++) {\n      // first key dependencies\n      var testkey = keys[ii];\n\n      if (this.debug) {\n        console.log(\">>>Checking:\", testkey, \" vs Table:(\", trgkey, \",\", othkey, \") where=\", where, trgwhere);\n      }\n\n      ;\n      var othtable = [othkey, testkey];\n      var othdep = this.getDependancy(state, keywhere, othtable);\n\n      if (this.debug) {\n        console.log(\"        Other:   \", othkey, testkey, JSON.stringify(othdep));\n      }\n\n      ; // in case there are no targets\n\n      if (othdep.intprt[othkey] === \"insignificant\" || othdep.intprt[testkey] === \"insignificant\" || tblkey !== \"\") {\n        // ignore insignificant testkey\n        rest.push(testkey);\n\n        if (this.debug) {\n          console.log(\"****  Postpone:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey);\n        }\n\n        ;\n      } else if (othdep.intprt[testkey] === \"redundant\") {\n        // select redundant testkey\n        var testval = othdep.val[testkey];\n        var sid = -1;\n\n        if (soft) {\n          // force move\n          sid = state.Path.keys.path.indexOf(testkey); //console.log(\"Soft move:\",testkey,sid,JSON.stringify(state.Path.keys.path));\n        }\n\n        ;\n\n        if (testval !== null & sid === -1) {\n          // single value & \"not\" in path\n          sel.push(testkey);\n          val.push(testval);\n\n          if (this.debug) {\n            console.log(\"****  Select:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey, JSON.stringify(othdep), where);\n          }\n\n          ;\n        } else {\n          rest.push(testkey);\n\n          if (this.debug) {\n            console.log(\"****  Rest:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey, JSON.stringify(othdep), where);\n          }\n\n          ;\n        }\n      } else {\n        // control key\n        tblkey = testkey; // we have found a good candidate\n\n        if (this.debug) {\n          console.log(\"****  Target:\", testkey, JSON.stringify(sel), JSON.stringify(rest), tblkey);\n        }\n\n        ;\n      }\n    } //if(this.debug){console.log(\"Sel/Val:\",JSON.stringify(sel),JSON.stringify(val));};\n\n\n    var ret = {\n      sel: sel,\n      val: val,\n      rest: rest,\n      tblkey: tblkey,\n      othkey: othkey\n    };\n\n    if (this.debug) {\n      console.log(\"analyse Done:\", JSON.stringify(ret));\n    }\n\n    ;\n    return ret;\n  }; // check if keys are inter-dependent, (\"common\", \"unique\", \"dependent\", \"unknown\") \n\n\n  this.getDependancy = function (state, where, keys) {\n    //if(this.debug){console.log(\"getDependancy Entering:\",where,JSON.stringify(keys));};\n    var key; //var where = state.Database.getWhere(state);\n\n    var ret = {\n      dep: {},\n      val: {}\n    };\n    var hits = {};\n    var maxhits = {};\n    var docs = state.Database.getDocsCnt(state, where, keys); // current table keys\n    //if(this.debug){console.log(\"getDependancy:\",JSON.stringify(docs));};\n\n    var slen = keys.length;\n    var dlen = docs.length;\n\n    for (var ii = 0; ii < dlen; ii++) {\n      var doc = docs[ii];\n\n      for (var jj = 0; jj < slen; jj++) {\n        key = keys[jj];\n\n        if (doc[key] !== undefined) {\n          var val = doc[key];\n          ret.val[key] = val;\n\n          if (hits[key] === undefined) {\n            hits[key] = {};\n          }\n\n          hits[key][val] = 1 + (hits[key][val] || 0);\n\n          if (hits[key][val] > (maxhits[key] || 0)) {\n            maxhits[key] = hits[key][val];\n          }\n        }\n\n        ;\n      }\n    }\n\n    ; //if(this.debug){console.log(\"Hits:\",dlen,JSON.stringify(hits),where);};\n\n    for (var kk = 0; kk < slen; kk++) {\n      key = keys[kk];\n\n      if (maxhits[key] !== undefined) {\n        if (maxhits[key] === 1) {\n          // every entry has unique value\n          ret.dep[key] = \"unique\";\n        } else if (maxhits[key] === dlen) {\n          ret.dep[key] = \"common\"; // all entries have same value\n        } else {\n          ret.dep[key] = \"dependent\"; // entries depend on values\n        }\n      } else {\n        ret.dep[key] = \"unknown\"; // not found in database\n      }\n\n      if (hits[key] !== undefined) {\n        if (Object.keys(hits[key]).length > 1) {\n          ret.val[key] = null;\n        }\n      } else {//console.log(\"No hits for key:\",key);\n      }\n    }\n\n    ;\n    ret.intprt = this.getInterpretation(state, keys, ret.dep); //if(this.debug){console.log(\"getDependancy Done:\",JSON.stringify(ret));};\n\n    return ret;\n  };\n\n  this.getInterpretation = function (state, keys, dep) {\n    var key;\n    var interpretation = {};\n    var slen = keys.length;\n\n    for (var kk = 0; kk < slen; kk++) {\n      var kkey = keys[kk];\n      interpretation[kkey] = \"control\";\n    }\n\n    ;\n\n    for (var jj = 0; jj < slen; jj++) {\n      key = keys[jj];\n\n      if (dep[key] === \"unique\") {\n        // \"unique\" keys depend on the other keys...\n        for (var rr = 0; rr < slen; rr++) {\n          var rkey = keys[rr];\n\n          if (dep[rkey] === \"unique\") {\n            // do not remove every \"unique\" key\n            if (rr > jj) {\n              interpretation[rkey] = \"redundant\"; // later control variables are redundant\n            }\n\n            ;\n          } else {\n            // remove all other variables\n            if (rr !== jj) {\n              if (dep[rkey] === \"common\") {\n                interpretation[rkey] = \"redundant\"; // \n              } else {\n                interpretation[rkey] = \"insignificant\"; //\n              }\n\n              ;\n            }\n\n            ;\n          }\n        }\n      }\n    }\n\n    var cnt = 0;\n\n    for (var ll = slen - 1; ll >= 0; ll--) {\n      key = keys[ll];\n\n      if (dep[key] === \"common\") {\n        // common keys have only one value\n        cnt = cnt + 1;\n\n        if (cnt < slen) {\n          // leave at least one redundant variable\n          interpretation[key] = \"redundant\";\n        }\n      }\n    }\n\n    ;\n    return interpretation;\n  };\n}\n\n;\nexport default Auto;","map":{"version":3,"sources":["/home/franktt/react/varseltavle/src/lib/AutoLib.js"],"names":["Auto","debug","complete","toggle","state","console","log","Path","tkeys","Show","showConfig","setKeyNumber","exportAllKeys","first","getFirstKey","second","getSecondKey","where","Database","getWhere","othdep","getDependancy","other","table","dep","reorderKeys","JSON","stringify","keys","analysis","analyse","applyAnalysis","selectTableKey","key","keyval","keywhere","keycnt","keep","ret","sid","indexOf","rest","lenk","length","colkey","getColKey","rowkey","getRowKey","undefined","addTableKeyToPath","tableKeyToPath","moveOther2Table","duplicateTableKey","lens","jj","jkey","jkeyval","jkeywhere","ignore","tblkey","sel","val","push","Utils","clean","othkey","concat","trgkey","trgwhere","soft","addWhere","ii","testkey","othtable","intprt","testval","path","hits","maxhits","docs","getDocsCnt","slen","dlen","doc","kk","Object","getInterpretation","interpretation","kkey","rr","rkey","cnt","ll"],"mappings":"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","sourcesContent":["//console.log(\"Loading AutoLib.js\");\n\nfunction Auto() {\n    this.debug=false;\n    this.complete=true;\n    this.toggle=function(state) {\n\tconsole.log(\"Pressed toggle\");\n\tstate.Auto.complete=!state.Auto.complete;\n\tif (! state.Auto.complete) { state.Path.tkeys=2;}\n\tstate.Show.showConfig(state);\n    };\n    // re-arrange path...\n    this.setKeyNumber=function(state) {\n\tstate.Path.tkeys=2;\n\tif (state.Auto.complete) { // test 2 keys...\n\t    state.Path.exportAllKeys(state);\n\t    var first=state.Path.getFirstKey(state);\n\t    var second=state.Path.getSecondKey(state);\n\t    var where=state.Database.getWhere(state);\n\t    var othdep=this.getDependancy(state,where,\n\t\t\t\t\t  state.Path.other.table);\n\t    // check if keys are inter-dependent...\n\t    if ((othdep.dep[first]===\"dependent\" &\n\t\t othdep.dep[second]===\"unique\") ||\n\t\t(othdep.dep[first]===\"unique\" &\n\t\t othdep.dep[second]===\"dependent\")) {\n\t\t//console.log(\"**** Reordering anyways:\",JSON.stringify(othdep));\n\t\tthis.reorderKeys(state);\n\t    };\n\t    if (this.debug) {console.log(\"Keys:\",JSON.stringify(state.Path.other.table),\n\t\t\t\t\t JSON.stringify(othdep));}\n\t}\n    };\n    this.reorderKeys=function(state) {\n\tif (this.debug) {console.log(\"############# Reordering keys:\",JSON.stringify(state.Path.keys));}\n\tif (state.Auto.complete) {\n\t    state.Path.exportAllKeys(state);\n\t    var analysis=this.analyse(state);\n\t    this.applyAnalysis(state,analysis);\n\t    state.Path.exportAllKeys(state);\n\t    //console.log(\"############# Reordered keys:\",JSON.stringify(state.Path.keys));\n\t    //console.log(\"############# Reordered other:\",JSON.stringify(state.Path.other));\n\t};\n    };\n    // select given table key...\n    this.selectTableKey=function(state,key,keyval,keywhere,keycnt,keep) { // keep abscissa\n\tif(this.debug){console.log(\"selectTableKey Entering:\",key,keyval,keywhere,keycnt,JSON.stringify(state.Path.keys));};\n\tvar ret=false;\n\tvar sid = state.Path.keys.other.indexOf(key);\n\t//console.log(\"SelectTableKey:\",key,sid,JSON.stringify(state.Path.keys.other));\n\tif (sid !== -1 && key !== \"\") { // key is selectable, but maybe not in table...\n\t    // why do you need duplicates of the target key (that will be removed)? \n\t    // - to check if the new selection makes your table keys redundant...\n\t    // You need to check the table keys again. \n\t    // We duplicate the target key into the table array and then remove both copies. \n\t    // This brings the old table keys back again, making them subject to a redundancy check.\n\t    var keys=state.Path.other.rest;\n\t    var lenk=keys.length;\n\t    var colkey=state.Path.getColKey(state);\n\t    var rowkey=state.Path.getRowKey(state);\n\t    if(this.debug){console.log(\"Autopath or not?:\",lenk,colkey,rowkey,sid,state.Auto.complete);};\n\t    if (keep !== undefined & keep) { // only move key, no auto select\n\t\tret = state.Path.addTableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t    } else if (lenk===0 || colkey===undefined || rowkey===undefined || ! state.Auto.complete ) { // nothing to consider\n\t\tret = state.Path.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t    } else if (key !== colkey && key !== rowkey) { // plain select...\n\t\tret = state.Path.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t    } else { // auto-select\n\t\tstate.Path.moveOther2Table(state,key);   // move target key to front of array\n\t\tstate.Path.duplicateTableKey(state,key); // make duplicate\n\t\tstate.Path.exportAllKeys(state);\n\t\t//if(this.debug){console.log(\"Before:\",JSON.stringify(state.Path.keys));};\n\t\tret = state.Auto.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\t\tstate.Path.exportAllKeys(state);\n\t\tret = state.Auto.tableKeyToPath(state,key,keyval,keywhere,keycnt); // remove duplicate\n\t    }\n\t};\n\tif (ret) {state.Path.exportAllKeys(state);};\n\tif(this.debug){console.log(\"selectTableKey Done:\",JSON.stringify(state.Path.keys),JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.applyAnalysis=function(state,analysis) {\n\tvar lens, jj, jkey, jkeyval, jkeywhere;\n\tvar rest=[];\n\tvar ignore=state.Path.other.ignore;\n\tif (analysis.tblkey !== \"\" || (analysis.sel.length > 0 || analysis.rest.length > 0)) {\n\t    lens=analysis.sel.length;\n\t    for (jj=0;jj<lens;jj++) {\n\t\tjkey=analysis.sel[jj];\n\t\tjkeyval=analysis.val[jj];\n\t\tjkeywhere=jkey + \"='\" + jkeyval+\"'\";\n\t\tif (jkeyval !== null) {\n                    state.Path.tableKeyToPath(state,jkey,jkeyval,jkeywhere,1);\n\t\t} else {\n\t\t    console.log(\"Panick-mode:\",jkey);\n\t\t    analysis.rest.push(jkey);\n\t\t}\n\t    }\n\t    if(this.debug){console.log(\"tableKeyToPath Init:\",JSON.stringify(state.Path.keys));};\n\t    rest=state.Utils.clean(analysis.rest);\n\t}\n\tif (analysis.tblkey !== \"\") {\n\t    state.Path.tkeys=2;\n\t    state.Path.keys.other=state.Utils.clean([analysis.othkey,analysis.tblkey].concat(rest).concat(ignore));\n\t} else if (analysis.othkey !== undefined) {\n\t    state.Path.tkeys=1;\n\t    state.Path.keys.other=state.Utils.clean([analysis.othkey].concat(rest).concat(ignore));\n\t} else {\n\t    state.Path.tkeys=1;\n\t    state.Path.keys.other=state.Utils.clean([].concat(rest).concat(ignore));\n\t};\n    };\n    this.tableKeyToPath=function (state,key,keyval,keywhere,keycnt) {\n\t//if(this.debug){console.log(\"tableKeyToPath Entering:\",key,keyval,keywhere,keycnt);};\n\t// look for table-key candidates in the rest-stack\n\tvar analysis=this.analyse(state,key,keywhere);\n\t// move the key\n\tvar ret=state.Path.tableKeyToPath(state,key,keyval,keywhere,keycnt);\n\tthis.applyAnalysis(state,analysis);\n\tif(this.debug){console.log(\"Analysis:\",JSON.stringify(analysis));};\n\tif(this.debug){console.log(\"tableKeyToPath Path:\",JSON.stringify(state.Path.keys));};\n\tif(this.debug){console.log(\"tableKeyToPath Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.analyse=function(state,trgkey,trgwhere) {\n\tif(this.debug){console.log(\"analyseOther Entering:\",JSON.stringify(state.Path.other));};\n\t//other key\n\tvar keys;\n\tvar where=state.Database.getWhere(state);\n\tvar othkey;\n\tvar soft=false;\n\tif (trgkey===undefined) {\n\t    soft=true;\n\t    othkey=state.Path.getFirstKey(state);\n\t    trgkey=\"\";\n\t    trgwhere=\"\";\n\t    if (state.Path.tkeys===2) {\n\t\tkeys=[state.Path.getSecondKey(state)].concat(state.Path.other.rest);\n\t    } else {\n\t\tkeys=state.Path.other.rest;\n\t    };\n\t} else {\n\t    var colkey=state.Path.getColKey(state);\n\t    var rowkey=state.Path.getRowKey(state);\n\t    othkey=(trgkey===colkey?rowkey:colkey); // the other key\n\t    keys=state.Path.other.rest;\n\t};\n\tvar sel=[]; // selected\n\tvar val=[]; // values\n\tvar rest=[]; //rest\n\tvar tblkey=\"\"; // target key\n\tvar lenk=keys.length;\n\tvar keywhere=state.Database.addWhere(where,trgwhere);\n\t// redundant keys => selected\n\t// insignificant keys => pushed back\n\t// control keys => used in table\n\tfor (var ii = 0; ii< lenk; ii++) {\n\t    // first key dependencies\n\t    var testkey=keys[ii];\n\t    if(this.debug){console.log(\">>>Checking:\",testkey, \" vs Table:(\",trgkey,\",\",othkey,\") where=\",where,trgwhere);};\n\t    var othtable=[othkey,testkey];\n\t    var othdep=this.getDependancy(state,keywhere,othtable);\n\t    if(this.debug){console.log(\"        Other:   \",othkey,testkey,JSON.stringify(othdep));};\n\t    // in case there are no targets\n\t    if (othdep.intprt[othkey]===\"insignificant\" || othdep.intprt[testkey]===\"insignificant\" || tblkey !== \"\") {    // ignore insignificant testkey\n\t\trest.push(testkey);\n\t\tif(this.debug){console.log(\"****  Postpone:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey);};\n\t    } else if (othdep.intprt[testkey]===\"redundant\") { // select redundant testkey\n\t\tvar testval=othdep.val[testkey];\n\t\tvar sid=-1;\n\t\tif (soft) {// force move\n\t\t    sid = state.Path.keys.path.indexOf(testkey);\n\t\t    //console.log(\"Soft move:\",testkey,sid,JSON.stringify(state.Path.keys.path));\n\t\t};\n\t\tif (testval !== null & sid===-1) { // single value & \"not\" in path\n\t\t    sel.push(testkey);\n\t\t    val.push(testval);\n\t\t    if(this.debug){console.log(\"****  Select:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey,JSON.stringify(othdep),where);};\n\t\t} else {\n\t\t    rest.push(testkey);\n\t\t    if(this.debug){console.log(\"****  Rest:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey,JSON.stringify(othdep),where);};\n\t\t}\n\t    } else { // control key\n\t\ttblkey=testkey;                    // we have found a good candidate\n\t\tif(this.debug){console.log(\"****  Target:\",testkey,JSON.stringify(sel),JSON.stringify(rest),tblkey);};\n\t    }\n\t}\n\t//if(this.debug){console.log(\"Sel/Val:\",JSON.stringify(sel),JSON.stringify(val));};\n\tvar ret={sel:sel,val:val,rest:rest,tblkey:tblkey,othkey:othkey};\n\tif(this.debug){console.log(\"analyse Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    // check if keys are inter-dependent, (\"common\", \"unique\", \"dependent\", \"unknown\") \n    this.getDependancy=function(state,where,keys) {\n\t//if(this.debug){console.log(\"getDependancy Entering:\",where,JSON.stringify(keys));};\n\tvar key;\n\t//var where = state.Database.getWhere(state);\n\tvar ret={dep:{},val:{}};\n\tvar hits={};\n\tvar maxhits={};\n\tvar docs=state.Database.getDocsCnt(state,where,keys); // current table keys\n\t//if(this.debug){console.log(\"getDependancy:\",JSON.stringify(docs));};\n\tvar slen=keys.length;\n\tvar dlen = docs.length;\n\tfor (var ii = 0; ii < dlen; ii++) {\n    \t    var doc=docs[ii];\n\t    for (var jj=0;jj<slen;jj++) {\n\t\tkey=keys[jj];\n\t\tif (doc[key] !== undefined) {\n\t\t    var val=doc[key];\n\t\t    ret.val[key]=val;\n\t\t    if (hits[key]  === undefined) {hits[key]={};}\n\t\t    hits[key][val] = 1+ (hits[key][val]||0);\n\t\t    if (hits[key][val] > (maxhits[key]||0)) {\n\t\t\tmaxhits[key]=hits[key][val];\n\t\t    }\n\t\t};\n\t    }\n\t};\n\t//if(this.debug){console.log(\"Hits:\",dlen,JSON.stringify(hits),where);};\n\tfor (var kk=0;kk<slen;kk++) {\n\t    key=keys[kk];\n\t    if (maxhits[key] !== undefined) {\n\t\tif (maxhits[key]  === 1) {          // every entry has unique value\n\t\t    ret.dep[key]=\"unique\";\n\t\t} else if (maxhits[key]  === dlen) {\n\t\t    ret.dep[key]=\"common\";    // all entries have same value\n\t\t} else {\n\t\t    ret.dep[key]=\"dependent\";    // entries depend on values\n\t\t}\n\t    } else {\n\t\tret.dep[key]=\"unknown\"; // not found in database\n\t    }\n\t    if (hits[key]  !== undefined) {\n\t\tif (Object.keys(hits[key]).length > 1) {\n\t\t    ret.val[key]=null;\n\t\t}\n\t    } else {\n\t\t//console.log(\"No hits for key:\",key);\n\t    }\n\t};\n\tret.intprt=this.getInterpretation(state,keys,ret.dep);\n\t//if(this.debug){console.log(\"getDependancy Done:\",JSON.stringify(ret));};\n\treturn ret;\n    };\n    this.getInterpretation=function(state,keys,dep){\n\tvar key;\n\tvar interpretation={};\n\tvar slen=keys.length;\n\tfor (var kk=0;kk<slen;kk++) {\n\t    var kkey=keys[kk];\n\t    interpretation[kkey]=\"control\";\n\t};\n\tfor (var jj=0;jj<slen;jj++) {\n\t    key=keys[jj];\n\t    if (dep[key]  === \"unique\") {// \"unique\" keys depend on the other keys...\n\t\tfor (var rr=0;rr<slen;rr++) {\n\t\t    var rkey=keys[rr];\n\t\t    if (dep[rkey] === \"unique\") { // do not remove every \"unique\" key\n\t\t\tif (rr > jj) {\n\t\t\t    interpretation[rkey]=\"redundant\"; // later control variables are redundant\n\t\t\t};\n\t\t    } else { // remove all other variables\n\t\t\tif (rr !== jj) {\n\t\t\t    if (dep[rkey] === \"common\") {\n\t\t\t\tinterpretation[rkey]=\"redundant\"; // \n\t\t\t    } else {\n\t\t\t\tinterpretation[rkey]=\"insignificant\"; //\n\t\t\t    };\n\t\t\t};\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tvar cnt=0;\n\tfor (var ll=slen-1;ll>=0;ll--) {\n\t    key=keys[ll];\n\t    if (dep[key]  === \"common\") { // common keys have only one value\n\t\tcnt=cnt+1;\n\t\tif (cnt < slen) { // leave at least one redundant variable\n\t\t    interpretation[key]=\"redundant\";\n\t\t}\n\t    }\n\t};\n\treturn interpretation;\n    };\n};\nexport default Auto;\n"]},"metadata":{},"sourceType":"module"}