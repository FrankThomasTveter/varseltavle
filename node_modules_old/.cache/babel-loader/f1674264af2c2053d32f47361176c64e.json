{"ast":null,"code":"import _objectSpread from \"/home/franktt/react/varseltavle_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/home/franktt/react/varseltavle_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/franktt/react/varseltavle_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/franktt/react/varseltavle_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/franktt/react/varseltavle_new/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { scaleLinear } from 'd3-scale';\nimport * as TWEEN from 'es6-tween';\nimport { AmbientLight, BackSide, BoxGeometry, Color, Group, Mesh, MeshBasicMaterial, MeshLambertMaterial //    MeshStandardMaterial,\n, MeshPhongMaterial //    Object3D,\n, PerspectiveCamera, PointLight, Scene, SphereGeometry, TextureLoader, Vector3, WebGLRenderer } from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\nimport OrbitControls from 'three-orbitcontrols';\nimport { Interaction } from 'three.interaction';\nimport { BACKGROUND_RADIUS_SCALE, CAMERA_DAMPING_FACTOR, CAMERA_FAR, CAMERA_FOV, CAMERA_MIN_DISTANCE_RADIUS_SCALE, CAMERA_NEAR, CLOUDS_RADIUS_OFFSET, defaultCameraOptions, defaultFocusOptions, defaultGlobeOptions, defaultLightOptions, defaultMarkerOptions, GLOBE_SEGMENTS, INITIAL_COORDINATES, MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, MARKER_DEFAULT_COLOR, MARKER_SEGMENTS, MARKER_UNIT_RADIUS_SCALE, RADIUS } from './defaults';\nimport { //Animation,\n//Callbacks,\n//CameraOptions,\n//Coordinates,\n//FocusOptions,\n//GlobeOptions,\n//InteractableObject3D,\n//InteractableScene,\n//InteractionEvent,\n//LightOptions,\n//Marker,\n//MarkerOptions,\nMarkerType, ObjectName //Optional,\n//Options,\n//Position,\n//Size,\n} from './types';\nimport { coordinatesToPosition, getMarkerCoordinatesKey, maxValue, minValue, tween } from './utils';\n\nvar emptyFunction = function emptyFunction() {};\n\nvar defaultCallbacks = {\n  onClickMarker: emptyFunction,\n  onDefocus: emptyFunction,\n  onMouseOutMarker: emptyFunction,\n  onMouseOverMarker: emptyFunction,\n  onTextureLoaded: emptyFunction\n};\nvar defaultOptions = {\n  camera: defaultCameraOptions,\n  globe: defaultGlobeOptions,\n  focus: defaultFocusOptions,\n  marker: defaultMarkerOptions,\n  light: defaultLightOptions\n}; // utility function\n\nvar sceneTraverse = function sceneTraverse(obj, fn) {\n  if (!obj) return;\n  fn(obj);\n\n  if (obj.children && obj.children.length > 0) {\n    obj.children.forEach(function (o) {\n      sceneTraverse(o, fn);\n    });\n  }\n};\n\nvar cleanScene = function cleanScene(o) {\n  if (o.geometry) {\n    o.geometry.dispose(); //console.log(\"dispose geometry \", o.geometry)                        \n  }\n\n  if (o.material) {\n    if (o.material.length) {\n      for (var i = 0; i < o.material.length; ++i) {\n        o.material[i].dispose(); //console.log(\"dispose material \", o.material[i])                                \n      }\n    } else {\n      o.material.dispose(); //console.log(\"dispose material \", o.material)                            \n    }\n  }\n};\n\nvar Globe = /*#__PURE__*/function () {\n  function Globe(canvas, tooltip) {\n    var _this = this;\n\n    _classCallCheck(this, Globe);\n\n    // create objects\n    var renderer = new WebGLRenderer({\n      alpha: true,\n      antialias: true,\n      canvas\n    });\n    var camera = new PerspectiveCamera();\n    var cameraAmbientLight = new AmbientLight('white');\n    var cameraPointLight = new PointLight('white');\n    var globe = new Group();\n    var globeBackground = new Mesh();\n    var globeClouds = new Mesh();\n    var globeSphere = new Mesh();\n    var markerObjects = new Group();\n    var orbitControls = new OrbitControls(camera, renderer.domElement);\n    var scene = new Scene(); // name objects\n\n    camera.name = ObjectName.Camera;\n    cameraAmbientLight.name = ObjectName.CameraAmbientLight;\n    cameraPointLight.name = ObjectName.CameraPointLight;\n    globe.name = ObjectName.Globe;\n    globeBackground.name = ObjectName.GlobeBackground;\n    globeClouds.name = ObjectName.GlobeClouds;\n    globeSphere.name = ObjectName.GlobeSphere;\n    markerObjects.name = ObjectName.MarkerObjects;\n    scene.name = ObjectName.Scene; // add objects to scene\n\n    camera.add(cameraAmbientLight);\n    camera.add(cameraPointLight);\n    globe.add(globeBackground);\n    globe.add(globeClouds);\n    globe.add(globeSphere);\n    scene.add(markerObjects);\n    scene.add(camera);\n    scene.add(globe); // add interactions to scene\n\n    var interactions = new Interaction(renderer, scene, camera);\n    scene.on('mousemove', function (event) {\n      if (_this.isFocusing()) {\n        return;\n      }\n\n      if (_this.activeMarker) {\n        var activeScale = _this.options.marker.activeScale;\n        var from = [activeScale, activeScale, activeScale];\n        tween(from, [1, 1, 1], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n          if (_this.activeMarkerObject) {\n            var _this$activeMarkerObj;\n\n            (_this$activeMarkerObj = _this.activeMarkerObject.scale).set.apply(_this$activeMarkerObj, from);\n          }\n        }, function () {\n          _this.activeMarker = undefined;\n          _this.activeMarkerObject = undefined;\n        });\n\n        _this.callbacks.onMouseOutMarker(_this.activeMarker, _this.activeMarkerObject, event.data.originalEvent); //this.tooltip.hide(); // the tooltip hides itself...\n\n      }\n    });\n    scene.on('click', function (event) {\n      if (_this.isFocusing()) {\n        return;\n      }\n\n      if (_this.options.focus.enableDefocus && _this.preFocusPosition) {\n        _this.callbacks.onDefocus(_this.focus, event.data.originalEvent);\n\n        _this.updateFocus(undefined, _this.options.focus);\n      }\n    }); // assign values to class variables\n\n    this.activeMarker = undefined;\n    this.activeMarkerObject = undefined;\n    this.animationFrameId = undefined;\n    this.callbacks = defaultCallbacks;\n    this.camera = camera;\n    this.focus = undefined;\n    this.globe = globe;\n    this.isFrozen = false;\n    this.markerObjects = markerObjects;\n    this.options = defaultOptions;\n    this.orbitControls = orbitControls;\n    this.preFocusPosition = undefined;\n    this.renderer = renderer;\n    this.interactions = interactions;\n    this.scene = scene;\n    this.tooltip = tooltip; // update objects\n\n    this.updateCallbacks();\n    this.updateCamera();\n    this.updateFocus();\n    this.updateGlobe({\n      enableBackground: false,\n      enableClouds: false\n    });\n    this.updateLights();\n    this.updateMarkers();\n    this.updateSize();\n  }\n\n  _createClass(Globe, [{\n    key: \"cleanMarker\",\n    value: function cleanMarker(markerObject) {\n      markerObject.on('click', null);\n      markerObject.on('touchstart', null);\n      markerObject.on('mousemove', null);\n      markerObject.geometry.dispose();\n      markerObject.material.dispose();\n      markerObject.children.forEach(function (companion) {\n        markerObject.remove(companion);\n        companion.geometry.dispose();\n        companion.material.dispose();\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      //console.log(\"Destroying Globe...\");\n      cancelAnimationFrame(this.animationFrameId);\n      this.tooltip.destroy();\n      this.tooltip = null; // dispose globe, clouds and background...\n\n      var globeBackground = this.getObjectByName(ObjectName.GlobeBackground);\n      var globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n      var globeSphere = this.getObjectByName(ObjectName.GlobeSphere);\n      this.globe.remove(globeBackground);\n      this.globe.remove(globeClouds);\n      this.globe.remove(globeSphere);\n      this.scene.remove(this.globe);\n      globeBackground.geometry.dispose();\n      globeBackground.material.dispose();\n      globeClouds.geometry.dispose();\n      globeClouds.material.dispose();\n      globeSphere.geometry.dispose();\n      globeSphere.material.dispose(); // dispose markers\n\n      this.markerObjects.children.forEach(function (markerObject) {\n        _this2.markerObjects.remove(markerObject);\n\n        _this2.cleanMarker(markerObject);\n      });\n      this.interactions.removeAllListeners = this.interactions.removeEvents;\n      this.interactions.destroy();\n      this.interactions.on('addevents', null);\n      this.interactions.on('removeevents', null);\n      this.interactions.setTargetElement(null);\n      this.interactions = null;\n      this.scene.remove(this.markerObjects);\n      this.markerObjects = null; // clean up...\n\n      this.scene.on('mousemove', null);\n      this.scene.on('click', null);\n      sceneTraverse(this.scene, cleanScene);\n      this.scene.dispose();\n      this.scene = null;\n      this.renderer && this.renderer.renderLists.dispose();\n      this.renderer.dispose();\n      this.renderer = null;\n      this.orbitControls.dispose();\n      this.orbitControls = null;\n      this.preFocusPosition = null;\n      ;\n      this.camera.children.forEach(function (object) {\n        _this2.camera.remove(object);\n      });\n      this.camera = null;\n    }\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      this.render();\n      this.animationFrameId = requestAnimationFrame(this.animate.bind(this));\n    } // TODO: expose a way to customize animating clouds in every axis\n\n  }, {\n    key: \"animateClouds\",\n    value: function animateClouds() {\n      var globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n      ['x', 'y', 'z'].forEach(function (axis) {\n        globeClouds.rotation[axis] += Math.random() / 10000;\n      });\n    } // For each animation, update the focus and focusOptions provided by the animation over an array of timeouts\n\n  }, {\n    key: \"applyAnimations\",\n    value: function applyAnimations(animations) {\n      var _this3 = this;\n\n      var currentFocus = this.focus;\n      var currentFocusOptions = this.options.focus;\n      var wait = 0;\n      var timeouts = [];\n      animations.forEach(function (animation) {\n        var animationDuration = animation.animationDuration,\n            coordinates = animation.coordinates,\n            distanceRadiusScale = animation.distanceRadiusScale,\n            easingFunction = animation.easingFunction;\n        var timeout = setTimeout(function () {\n          _this3.updateFocus(coordinates, {\n            animationDuration,\n            distanceRadiusScale,\n            easingFunction\n          }, true);\n        }, wait);\n        timeouts.push(timeout);\n        wait += animationDuration;\n      }); // return cleanup function\n\n      return function () {\n        timeouts.forEach(function (timeout) {\n          clearTimeout(timeout);\n        });\n\n        _this3.updateFocus(currentFocus, currentFocusOptions);\n      };\n    }\n  }, {\n    key: \"enableOrbitControls\",\n    value: function enableOrbitControls(enabled) {\n      var autoRotate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : enabled;\n      this.orbitControls.enabled = enabled;\n      this.orbitControls.autoRotate = autoRotate;\n    }\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      this.isFrozen = true;\n      this.enableOrbitControls(false);\n      cancelAnimationFrame(this.animationFrameId);\n    }\n  }, {\n    key: \"getObjectByName\",\n    value: function getObjectByName(name) {\n      return this.scene.getObjectByName(name);\n    }\n  }, {\n    key: \"isFocusing\",\n    value: function isFocusing() {\n      return !this.orbitControls.enabled;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.renderer.sortObjects = false;\n      this.renderer.render(this.scene, this.camera);\n      this.animateClouds();\n      this.orbitControls.update();\n      TWEEN.update();\n    }\n  }, {\n    key: \"updateCallbacks\",\n    value: function updateCallbacks() {\n      var _this4 = this;\n\n      var callbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(defaultCallbacks).forEach(function (key) {\n        _this4.callbacks[key] = callbacks[key] || defaultCallbacks[key];\n      });\n    }\n  }, {\n    key: \"updateCamera\",\n    value: function updateCamera() {\n      var initialCoordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_COORDINATES;\n      var cameraOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.updateOptions(cameraOptions, 'camera');\n      var _this$options$camera = this.options.camera,\n          autoRotateSpeed = _this$options$camera.autoRotateSpeed,\n          distanceRadiusScale = _this$options$camera.distanceRadiusScale,\n          enableAutoRotate = _this$options$camera.enableAutoRotate,\n          enableRotate = _this$options$camera.enableRotate,\n          enableZoom = _this$options$camera.enableZoom,\n          maxDistanceRadiusScale = _this$options$camera.maxDistanceRadiusScale,\n          maxPolarAngle = _this$options$camera.maxPolarAngle,\n          minPolarAngle = _this$options$camera.minPolarAngle,\n          rotateSpeed = _this$options$camera.rotateSpeed,\n          zoomSpeed = _this$options$camera.zoomSpeed;\n\n      if (this.initialCoordinates !== initialCoordinates) {\n        var _coordinatesToPositio = coordinatesToPosition(initialCoordinates, RADIUS * distanceRadiusScale),\n            _coordinatesToPositio2 = _slicedToArray(_coordinatesToPositio, 3),\n            x = _coordinatesToPositio2[0],\n            y = _coordinatesToPositio2[1],\n            z = _coordinatesToPositio2[2];\n\n        this.camera.position.set(x, y, z);\n        this.initialCoordinates = initialCoordinates;\n      }\n\n      this.camera.far = CAMERA_FAR;\n      this.camera.fov = CAMERA_FOV;\n      this.camera.near = CAMERA_NEAR;\n      this.orbitControls.autoRotate = enableAutoRotate;\n      this.orbitControls.autoRotateSpeed = autoRotateSpeed;\n      this.orbitControls.dampingFactor = CAMERA_DAMPING_FACTOR;\n      this.orbitControls.enableDamping = true;\n      this.orbitControls.enablePan = false;\n      this.orbitControls.enableRotate = enableRotate;\n      this.orbitControls.enableZoom = enableZoom;\n      this.orbitControls.maxDistance = RADIUS * maxDistanceRadiusScale;\n      this.orbitControls.maxPolarAngle = maxPolarAngle;\n      this.orbitControls.minDistance = RADIUS * CAMERA_MIN_DISTANCE_RADIUS_SCALE;\n      this.orbitControls.minPolarAngle = minPolarAngle;\n      this.orbitControls.rotateSpeed = rotateSpeed;\n      this.orbitControls.zoomSpeed = zoomSpeed;\n    }\n  }, {\n    key: \"updateFocus\",\n    value: function updateFocus(focus) {\n      var _this5 = this;\n\n      var focusOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var autoDefocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.updateOptions(focusOptions, 'focus');\n      this.focus = focus;\n      var _this$options$focus = this.options.focus,\n          animationDuration = _this$options$focus.animationDuration,\n          distanceRadiusScale = _this$options$focus.distanceRadiusScale,\n          easingFunction = _this$options$focus.easingFunction;\n\n      if (this.isFrozen) {\n        return;\n      }\n\n      if (this.focus) {\n        // disable orbit controls when focused\n        var from = [this.camera.position.x, this.camera.position.y, this.camera.position.z];\n        var to = coordinatesToPosition(this.focus, RADIUS * distanceRadiusScale);\n        this.preFocusPosition = this.preFocusPosition || [].concat(from);\n        tween(from, to, animationDuration, easingFunction, function () {\n          var _this5$camera$positio;\n\n          _this5.enableOrbitControls(false);\n\n          (_this5$camera$positio = _this5.camera.position).set.apply(_this5$camera$positio, from);\n        }, function () {\n          if (autoDefocus) {\n            _this5.focus = undefined;\n            _this5.preFocusPosition = undefined;\n          }\n\n          _this5.enableOrbitControls(true, autoDefocus);\n        });\n      } else {\n        if (this.preFocusPosition) {\n          var _from = [this.camera.position.x, this.camera.position.y, this.camera.position.z];\n          var _to = this.preFocusPosition;\n          tween(_from, _to, animationDuration, easingFunction, function () {\n            var _this5$camera$positio2;\n\n            _this5.enableOrbitControls(false);\n\n            (_this5$camera$positio2 = _this5.camera.position).set.apply(_this5$camera$positio2, _from);\n          }, function () {\n            _this5.preFocusPosition = undefined;\n\n            _this5.enableOrbitControls(true);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"updateGlobe\",\n    value: function updateGlobe() {\n      var _this6 = this;\n\n      var globeOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.updateOptions(globeOptions, 'globe');\n      var _this$options$globe = this.options.globe,\n          backgroundTexture = _this$options$globe.backgroundTexture,\n          cloudsOpacity = _this$options$globe.cloudsOpacity,\n          cloudsTexture = _this$options$globe.cloudsTexture,\n          enableBackground = _this$options$globe.enableBackground,\n          enableClouds = _this$options$globe.enableClouds,\n          enableGlow = _this$options$globe.enableGlow,\n          glowColor = _this$options$globe.glowColor,\n          glowCoefficient = _this$options$globe.glowCoefficient,\n          glowPower = _this$options$globe.glowPower,\n          glowRadiusScale = _this$options$globe.glowRadiusScale,\n          bumpMap = _this$options$globe.bumpMap,\n          texture = _this$options$globe.texture;\n      var globeBackground = this.getObjectByName(ObjectName.GlobeBackground);\n      var globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n      var globeSphere = this.getObjectByName(ObjectName.GlobeSphere);\n      new TextureLoader().load(texture, function (map) {\n        console.log(\"Loaded texture:\", texture);\n        new TextureLoader().load(bumpMap, function (bump) {\n          console.log(\"Loaded bumpMap:\", bumpMap);\n          globeSphere.material = new MeshPhongMaterial({\n            map: map,\n            bumpMap: bump,\n            bumpScale: 5.0\n          }); //map,\n\n          globeSphere.geometry = new SphereGeometry(RADIUS, GLOBE_SEGMENTS, GLOBE_SEGMENTS); //globeSphere.material = new MeshLambertMaterial({\n\n          if (enableGlow) {\n            if (_this6.getObjectByName(ObjectName.GlobeGlow) !== undefined) {\n              globeSphere.remove(_this6.getObjectByName(ObjectName.GlobeGlow));\n            }\n\n            ;\n            var globeGlow = createGlowMesh(globeSphere.geometry, {\n              backside: true,\n              color: glowColor,\n              coefficient: glowCoefficient,\n              power: glowPower,\n              size: RADIUS * glowRadiusScale\n            });\n            globeGlow.name = ObjectName.GlobeGlow;\n            globeSphere.add(globeGlow);\n          }\n\n          ;\n\n          _this6.callbacks.onTextureLoaded();\n        });\n      }, undefined, function (err) {\n        console.error('Error gl-texture: ', texture, err);\n      });\n\n      if (enableBackground) {\n        new TextureLoader().load(backgroundTexture, function (map) {\n          globeBackground.geometry = new SphereGeometry(RADIUS * BACKGROUND_RADIUS_SCALE, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n          globeBackground.material = new MeshBasicMaterial({\n            map,\n            side: BackSide\n          });\n        }, undefined, function (err) {\n          console.error('Error bg-texture: ', backgroundTexture, err);\n        });\n      }\n\n      if (enableClouds) {\n        console.log(\"Loading cl texture:\", cloudsTexture);\n        new TextureLoader().load(cloudsTexture, function (map) {\n          globeClouds.geometry = new SphereGeometry(RADIUS + CLOUDS_RADIUS_OFFSET, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n          globeClouds.material = new MeshLambertMaterial({\n            map,\n            transparent: true\n          });\n          globeClouds.material.opacity = cloudsOpacity;\n        }, undefined, function (err) {\n          console.error('Error cl-texture: ', cloudsTexture, err);\n        });\n      }\n    }\n  }, {\n    key: \"updateLights\",\n    value: function updateLights() {\n      var lightOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.updateOptions(lightOptions, 'light');\n      var _this$options$light = this.options.light,\n          ambientLightColor = _this$options$light.ambientLightColor,\n          ambientLightIntensity = _this$options$light.ambientLightIntensity,\n          pointLightColor = _this$options$light.pointLightColor,\n          pointLightIntensity = _this$options$light.pointLightIntensity,\n          pointLightPositionRadiusScales = _this$options$light.pointLightPositionRadiusScales;\n      var cameraAmbientLight = this.getObjectByName(ObjectName.CameraAmbientLight);\n      var cameraPointLight = this.getObjectByName(ObjectName.CameraPointLight);\n      cameraAmbientLight.color = new Color(ambientLightColor);\n      cameraAmbientLight.intensity = ambientLightIntensity;\n      cameraPointLight.color = new Color(pointLightColor);\n      cameraPointLight.intensity = pointLightIntensity;\n      cameraPointLight.position.set(RADIUS * pointLightPositionRadiusScales[0], RADIUS * pointLightPositionRadiusScales[1], RADIUS * pointLightPositionRadiusScales[2]);\n    }\n  }, {\n    key: \"updateMarkers\",\n    value: function updateMarkers() {\n      var _this7 = this;\n\n      var markers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var markerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.updateOptions(markerOptions, 'marker');\n      var _this$options$marker = this.options.marker,\n          activeScale = _this$options$marker.activeScale,\n          enableGlow = _this$options$marker.enableGlow,\n          enableTooltip = _this$options$marker.enableTooltip,\n          enterAnimationDuration = _this$options$marker.enterAnimationDuration,\n          enterEasingFunction = _this$options$marker.enterEasingFunction,\n          exitAnimationDuration = _this$options$marker.exitAnimationDuration,\n          exitEasingFunction = _this$options$marker.exitEasingFunction,\n          glowCoefficient = _this$options$marker.glowCoefficient,\n          glowPower = _this$options$marker.glowPower,\n          glowRadiusScale = _this$options$marker.glowRadiusScale,\n          offsetRadiusScale = _this$options$marker.offsetRadiusScale,\n          radiusScaleRange = _this$options$marker.radiusScaleRange,\n          renderer = _this$options$marker.renderer,\n          type = _this$options$marker.type;\n      var unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE;\n      var sizeScale = scaleLinear().domain([minValue(markers, function (marker) {\n        return marker.value;\n      }), maxValue(markers, function (marker) {\n        return marker.value;\n      })]).range([RADIUS * radiusScaleRange[0], RADIUS * radiusScaleRange[1]]);\n      var markerCoordinatesKeys = new Set(markers.map(getMarkerCoordinatesKey));\n      var markerObjectNames = new Set(this.markerObjects.children.map(function (markerObject) {\n        return markerObject.name;\n      }));\n      markers.forEach(function (marker) {\n        var coordinates = marker.coordinates,\n            value = marker.value;\n        var markerCoordinatesKey = getMarkerCoordinatesKey(marker);\n        var size = sizeScale(value);\n        var markerObject; // create new marker objects\n\n        if (!markerObjectNames.has(markerCoordinatesKey)) {\n          var _markerObject$positio;\n\n          if (renderer !== undefined) {\n            markerObject = renderer(marker);\n          } else {\n            var color = marker.color || MARKER_DEFAULT_COLOR;\n            var from = {\n              size: 0\n            };\n            var to = {\n              size\n            };\n            var mesh = new Mesh();\n            tween(from, to, enterAnimationDuration, enterEasingFunction, function () {\n              switch (type) {\n                case MarkerType.Bar:\n                  mesh.geometry = new BoxGeometry(unitRadius, unitRadius, from.size);\n                  mesh.material = new MeshLambertMaterial({\n                    color\n                  });\n                  break;\n\n                case MarkerType.Dot:\n                default:\n                  mesh.geometry = new SphereGeometry(from.size, MARKER_SEGMENTS, MARKER_SEGMENTS);\n                  mesh.material = new MeshBasicMaterial({\n                    color\n                  });\n\n                  if (enableGlow) {\n                    // add glow\n                    var glowMesh = createGlowMesh(mesh.geometry.clone(), {\n                      backside: false,\n                      color,\n                      coefficient: glowCoefficient,\n                      power: glowPower,\n                      size: from.size * glowRadiusScale\n                    });\n                    mesh.children = [];\n                    mesh.add(glowMesh);\n                  }\n\n              }\n            });\n            markerObject = mesh;\n          } // place markers\n\n\n          var heightOffset = 0;\n\n          if (offsetRadiusScale !== undefined) {\n            heightOffset = RADIUS * offsetRadiusScale;\n          } else {\n            if (type === MarkerType.Dot) {\n              heightOffset = size * (1 + glowRadiusScale) / 2;\n            } else {\n              heightOffset = 0;\n            }\n          }\n\n          var position = coordinatesToPosition(coordinates, RADIUS + heightOffset);\n\n          (_markerObject$positio = markerObject.position).set.apply(_markerObject$positio, _toConsumableArray(position));\n\n          markerObject.lookAt(new Vector3(0, 0, 0));\n          markerObject.name = markerCoordinatesKey;\n\n          _this7.markerObjects.add(markerObject);\n        } // update existing marker objects\n\n\n        markerObject = _this7.markerObjects.getObjectByName(markerCoordinatesKey);\n\n        var handleClick = function handleClick(event) {\n          event.stopPropagation();\n\n          _this7.updateFocus(marker.coordinates);\n\n          _this7.callbacks.onClickMarker(marker, markerObject, event.data.originalEvent);\n        };\n\n        markerObject.on('click', handleClick.bind(_this7));\n        markerObject.on('touchstart', handleClick.bind(_this7));\n        markerObject.on('mousemove', function (event) {\n          if (_this7.isFocusing()) {\n            _this7.tooltip.hide();\n\n            return;\n          }\n\n          var originalEvent = event.data.originalEvent;\n\n          if (enableTooltip) {\n            //console.log(\"Marker:\",JSON.stringify(marker.id));\n            _this7.tooltip.show(originalEvent.clientX, originalEvent.clientY, marker);\n          }\n\n          if (true) {\n            return;\n          }\n\n          ;\n          event.stopPropagation();\n          var from = markerObject.scale.toArray();\n          tween(from, [activeScale, activeScale, activeScale], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n            if (markerObject) {\n              var _markerObject$scale;\n\n              (_markerObject$scale = markerObject.scale).set.apply(_markerObject$scale, _toConsumableArray(from));\n            }\n          });\n          _this7.activeMarker = marker;\n          _this7.activeMarkerObject = markerObject;\n\n          _this7.callbacks.onMouseOverMarker(marker, markerObject, originalEvent);\n        });\n      }); // remove marker objects that are stale\n\n      var markerObjectsToRemove = this.markerObjects.children.filter(function (markerObject) {\n        return !markerCoordinatesKeys.has(markerObject.name);\n      });\n      markerObjectsToRemove.forEach(function (markerObject) {\n        var from = markerObject.scale.toArray();\n        tween(from, [0, 0, 0], exitAnimationDuration, exitEasingFunction, function () {\n          if (markerObject) {\n            var _markerObject$scale2;\n\n            (_markerObject$scale2 = markerObject.scale).set.apply(_markerObject$scale2, _toConsumableArray(from));\n          }\n        }, function () {\n          _this7.markerObjects.remove(markerObject);\n\n          _this7.cleanMarker(markerObject);\n        });\n      });\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(options, key) {\n      this.options = _objectSpread(_objectSpread({}, defaultOptions), {}, {\n        [key]: _objectSpread(_objectSpread({}, defaultOptions[key]), options)\n      });\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(size) {\n      if (size) {\n        var _size = _slicedToArray(size, 2),\n            width = _size[0],\n            height = _size[1];\n\n        this.renderer.setSize(width, height);\n        this.camera.aspect = width / height;\n      }\n\n      this.camera.updateProjectionMatrix();\n    }\n  }, {\n    key: \"unfreeze\",\n    value: function unfreeze() {\n      if (this.isFrozen) {\n        this.isFrozen = false;\n        this.enableOrbitControls(true);\n        this.animate();\n      }\n    }\n  }]);\n\n  return Globe;\n}();\n\nexport { Globe as default };","map":{"version":3,"sources":["/home/franktt/react/varseltavle_new/src/globe/Globe.js"],"names":["scaleLinear","TWEEN","AmbientLight","BackSide","BoxGeometry","Color","Group","Mesh","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","PerspectiveCamera","PointLight","Scene","SphereGeometry","TextureLoader","Vector3","WebGLRenderer","createGlowMesh","OrbitControls","Interaction","BACKGROUND_RADIUS_SCALE","CAMERA_DAMPING_FACTOR","CAMERA_FAR","CAMERA_FOV","CAMERA_MIN_DISTANCE_RADIUS_SCALE","CAMERA_NEAR","CLOUDS_RADIUS_OFFSET","defaultCameraOptions","defaultFocusOptions","defaultGlobeOptions","defaultLightOptions","defaultMarkerOptions","GLOBE_SEGMENTS","INITIAL_COORDINATES","MARKER_ACTIVE_ANIMATION_DURATION","MARKER_ACTIVE_ANIMATION_EASING_FUNCTION","MARKER_DEFAULT_COLOR","MARKER_SEGMENTS","MARKER_UNIT_RADIUS_SCALE","RADIUS","MarkerType","ObjectName","coordinatesToPosition","getMarkerCoordinatesKey","maxValue","minValue","tween","emptyFunction","defaultCallbacks","onClickMarker","onDefocus","onMouseOutMarker","onMouseOverMarker","onTextureLoaded","defaultOptions","camera","globe","focus","marker","light","sceneTraverse","obj","fn","children","length","forEach","o","cleanScene","geometry","dispose","material","i","Globe","canvas","tooltip","renderer","alpha","antialias","cameraAmbientLight","cameraPointLight","globeBackground","globeClouds","globeSphere","markerObjects","orbitControls","domElement","scene","name","Camera","CameraAmbientLight","CameraPointLight","GlobeBackground","GlobeClouds","GlobeSphere","MarkerObjects","add","interactions","on","event","isFocusing","activeMarker","activeScale","options","from","activeMarkerObject","scale","set","undefined","callbacks","data","originalEvent","enableDefocus","preFocusPosition","updateFocus","animationFrameId","isFrozen","updateCallbacks","updateCamera","updateGlobe","enableBackground","enableClouds","updateLights","updateMarkers","updateSize","markerObject","companion","remove","cancelAnimationFrame","destroy","getObjectByName","cleanMarker","removeAllListeners","removeEvents","setTargetElement","renderLists","object","render","requestAnimationFrame","animate","bind","axis","rotation","Math","random","animations","currentFocus","currentFocusOptions","wait","timeouts","animation","animationDuration","coordinates","distanceRadiusScale","easingFunction","timeout","setTimeout","push","clearTimeout","enabled","autoRotate","enableOrbitControls","sortObjects","animateClouds","update","Object","keys","key","initialCoordinates","cameraOptions","updateOptions","autoRotateSpeed","enableAutoRotate","enableRotate","enableZoom","maxDistanceRadiusScale","maxPolarAngle","minPolarAngle","rotateSpeed","zoomSpeed","x","y","z","position","far","fov","near","dampingFactor","enableDamping","enablePan","maxDistance","minDistance","focusOptions","autoDefocus","to","globeOptions","backgroundTexture","cloudsOpacity","cloudsTexture","enableGlow","glowColor","glowCoefficient","glowPower","glowRadiusScale","bumpMap","texture","load","map","console","log","bump","bumpScale","GlobeGlow","globeGlow","backside","color","coefficient","power","size","err","error","side","transparent","opacity","lightOptions","ambientLightColor","ambientLightIntensity","pointLightColor","pointLightIntensity","pointLightPositionRadiusScales","intensity","markers","markerOptions","enableTooltip","enterAnimationDuration","enterEasingFunction","exitAnimationDuration","exitEasingFunction","offsetRadiusScale","radiusScaleRange","type","unitRadius","sizeScale","domain","value","range","markerCoordinatesKeys","Set","markerObjectNames","markerCoordinatesKey","has","mesh","Bar","Dot","glowMesh","clone","heightOffset","lookAt","handleClick","stopPropagation","hide","show","clientX","clientY","toArray","markerObjectsToRemove","filter","width","height","setSize","aspect","updateProjectionMatrix"],"mappings":"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","sourcesContent":["import { scaleLinear } from 'd3-scale';\nimport * as TWEEN from 'es6-tween';\nimport {\n    AmbientLight,\n    BackSide,\n    BoxGeometry,\n    Color,\n    Group,\n    Mesh,\n    MeshBasicMaterial,\n    MeshLambertMaterial,\n//    MeshStandardMaterial,\n    MeshPhongMaterial,\n//    Object3D,\n    PerspectiveCamera,\n    PointLight,\n    Scene,\n    SphereGeometry,\n    TextureLoader,\n    Vector3,\n    WebGLRenderer,\n} from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\nimport OrbitControls from 'three-orbitcontrols';\nimport { Interaction } from 'three.interaction';\n\nimport {\n    BACKGROUND_RADIUS_SCALE,\n    CAMERA_DAMPING_FACTOR,\n    CAMERA_FAR,\n    CAMERA_FOV,\n    CAMERA_MIN_DISTANCE_RADIUS_SCALE,\n    CAMERA_NEAR,\n    CLOUDS_RADIUS_OFFSET,\n    defaultCameraOptions,\n    defaultFocusOptions,\n    defaultGlobeOptions,\n    defaultLightOptions,\n    defaultMarkerOptions,\n    GLOBE_SEGMENTS,\n    INITIAL_COORDINATES,\n    MARKER_ACTIVE_ANIMATION_DURATION,\n    MARKER_ACTIVE_ANIMATION_EASING_FUNCTION,\n    MARKER_DEFAULT_COLOR,\n    MARKER_SEGMENTS,\n    MARKER_UNIT_RADIUS_SCALE,\n    RADIUS,\n} from './defaults';\nimport {\n    //Animation,\n    //Callbacks,\n    //CameraOptions,\n    //Coordinates,\n    //FocusOptions,\n    //GlobeOptions,\n    //InteractableObject3D,\n    //InteractableScene,\n    //InteractionEvent,\n    //LightOptions,\n    //Marker,\n    //MarkerOptions,\n    MarkerType,\n    ObjectName,\n    //Optional,\n    //Options,\n    //Position,\n    //Size,\n} from './types';\nimport {\n    coordinatesToPosition,\n    getMarkerCoordinatesKey,\n    maxValue,\n    minValue,\n    tween,\n} from './utils';\n\nconst emptyFunction = () => {};\n\nconst defaultCallbacks = {\n    onClickMarker: emptyFunction,\n    onDefocus: emptyFunction,\n    onMouseOutMarker: emptyFunction,\n    onMouseOverMarker: emptyFunction,\n    onTextureLoaded: emptyFunction,\n};\n\nconst defaultOptions = {\n    camera: defaultCameraOptions,\n    globe: defaultGlobeOptions,\n    focus: defaultFocusOptions,\n    marker: defaultMarkerOptions,\n    light: defaultLightOptions,\n};\n// utility function\nconst sceneTraverse = (obj, fn) => {\n    if (!obj) return\n    fn(obj)\n    if (obj.children && obj.children.length > 0) {\n\tobj.children.forEach(o => {\n\t    sceneTraverse(o, fn)\n\t})\n    }\n}\n\nconst cleanScene =  (o) => {\n    if (o.geometry) {\n        o.geometry.dispose()\n        //console.log(\"dispose geometry \", o.geometry)                        \n    }\n    if (o.material) {\n        if (o.material.length) {\n            for (let i = 0; i < o.material.length; ++i) {\n                o.material[i].dispose()\n                //console.log(\"dispose material \", o.material[i])                                \n            }\n        }\n        else {\n            o.material.dispose()\n            //console.log(\"dispose material \", o.material)                            \n        }\n    }\n};\n\nexport default class Globe {\n    constructor(canvas, tooltip) {\n\t// create objects\n\tconst renderer = new WebGLRenderer({\n\t    alpha: true,\n\t    antialias: true,\n\t    canvas,\n\t});\n\tconst camera = new PerspectiveCamera();\n\tconst cameraAmbientLight = new AmbientLight('white');\n\tconst cameraPointLight = new PointLight('white');\n\tconst globe = new Group();\n\tconst globeBackground = new Mesh();\n\tconst globeClouds = new Mesh();\n\tconst globeSphere = new Mesh();\n\tconst markerObjects = new Group();\n\tconst orbitControls = new OrbitControls(camera, renderer.domElement);\n\tconst scene = new Scene();\n\n\t// name objects\n\tcamera.name = ObjectName.Camera;\n\tcameraAmbientLight.name = ObjectName.CameraAmbientLight;\n\tcameraPointLight.name = ObjectName.CameraPointLight;\n\tglobe.name = ObjectName.Globe;\n\tglobeBackground.name = ObjectName.GlobeBackground;\n\tglobeClouds.name = ObjectName.GlobeClouds;\n\tglobeSphere.name = ObjectName.GlobeSphere;\n\tmarkerObjects.name = ObjectName.MarkerObjects;\n\tscene.name = ObjectName.Scene;\n\n\t// add objects to scene\n\tcamera.add(cameraAmbientLight);\n\tcamera.add(cameraPointLight);\n\tglobe.add(globeBackground);\n\tglobe.add(globeClouds);\n\tglobe.add(globeSphere);\n\tscene.add(markerObjects);\n\tscene.add(camera);\n\tscene.add(globe);\n\n\t// add interactions to scene\n\tconst interactions=new Interaction(renderer, scene, camera);\n\tscene.on('mousemove', (event) => {\n    \t    if (this.isFocusing()) {\n\t\treturn;\n      \t    }\n\t    if (this.activeMarker) {\n\t\tconst { activeScale } = this.options.marker;\n\t\tconst from = [activeScale, activeScale, activeScale];\n\t\ttween(\n\t\t    from,\n\t\t    [1, 1, 1],\n\t\t    MARKER_ACTIVE_ANIMATION_DURATION,\n\t\t    MARKER_ACTIVE_ANIMATION_EASING_FUNCTION,\n\t\t    () => {\n\t\t\tif (this.activeMarkerObject) {\n\t\t\t    this.activeMarkerObject.scale.set(...from);\n\t\t\t}\n\t\t    },\n\t\t    () => {\n\t\t\tthis.activeMarker = undefined;\n\t\t\tthis.activeMarkerObject = undefined;\n\t\t    },\n\t\t);\n\t\tthis.callbacks.onMouseOutMarker(\n\t\t    this.activeMarker,\n\t\t    this.activeMarkerObject,\n\t\t    event.data.originalEvent,\n\t\t);\n\t\t//this.tooltip.hide(); // the tooltip hides itself...\n\t    }\n\t});\n\tscene.on('click', (event) => {\n\t    if (this.isFocusing()) {\n\t\treturn;\n\t    }\n\t    if (this.options.focus.enableDefocus && this.preFocusPosition) {\n\t\tthis.callbacks.onDefocus(this.focus, event.data.originalEvent);\n\t\tthis.updateFocus(undefined, this.options.focus);\n\t    }\n\t});\n\t// assign values to class variables\n\tthis.activeMarker = undefined;\n\tthis.activeMarkerObject = undefined;\n\tthis.animationFrameId = undefined;\n\tthis.callbacks = defaultCallbacks;\n\tthis.camera = camera;\n\tthis.focus = undefined;\n\tthis.globe = globe;\n\tthis.isFrozen = false;\n\tthis.markerObjects = markerObjects;\n\tthis.options = defaultOptions;\n\tthis.orbitControls = orbitControls;\n\tthis.preFocusPosition = undefined;\n\tthis.renderer = renderer;\n\tthis.interactions = interactions;\n\tthis.scene = scene;\n\tthis.tooltip = tooltip;\n\n\t// update objects\n\tthis.updateCallbacks();\n\tthis.updateCamera();\n\tthis.updateFocus();\n\tthis.updateGlobe({\n\t    enableBackground: false,\n\t    enableClouds: false,\n\t});\n\tthis.updateLights();\n\tthis.updateMarkers();\n\tthis.updateSize();\n    }\n\n    cleanMarker(markerObject) {\n\tmarkerObject.on('click', null );\n\tmarkerObject.on('touchstart', null );\n\tmarkerObject.on('mousemove', null );\n\tmarkerObject.geometry.dispose();\n\tmarkerObject.material.dispose();\n\tmarkerObject.children.forEach(companion => {\n\t    markerObject.remove(companion);\n\t    companion.geometry.dispose();\n\t    companion.material.dispose();\n\t});\n    }\n\n    destroy() {\n\t//console.log(\"Destroying Globe...\");\n\tcancelAnimationFrame(this.animationFrameId);\n\tthis.tooltip.destroy();\n\tthis.tooltip=null;\n\t// dispose globe, clouds and background...\n\tconst globeBackground = this.getObjectByName(ObjectName.GlobeBackground);\n\tconst globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n\tconst globeSphere = this.getObjectByName(ObjectName.GlobeSphere);\n\tthis.globe.remove(globeBackground);\n\tthis.globe.remove(globeClouds);\n\tthis.globe.remove(globeSphere);\n\tthis.scene.remove(this.globe);\n\tglobeBackground.geometry.dispose();\n\tglobeBackground.material.dispose();\n\tglobeClouds.geometry.dispose();\n\tglobeClouds.material.dispose();\n\tglobeSphere.geometry.dispose();\n\tglobeSphere.material.dispose();\n\t// dispose markers\n\tthis.markerObjects.children.forEach(markerObject => {\n\t    this.markerObjects.remove(markerObject);\n\t    this.cleanMarker(markerObject);\n\t});\n\tthis.interactions.removeAllListeners= this.interactions.removeEvents;\n\tthis.interactions.destroy();\n\tthis.interactions.on('addevents',null);this.interactions.on('removeevents',null);this.interactions.setTargetElement(null);\n\tthis.interactions=null;\n\tthis.scene.remove(this.markerObjects);\n\tthis.markerObjects=null;\n\t// clean up...\n\tthis.scene.on('mousemove', null);\n\tthis.scene.on('click', null );\n\tsceneTraverse(this.scene, cleanScene);\n\tthis.scene.dispose();\n\tthis.scene=null;\n\tthis.renderer && this.renderer.renderLists.dispose();\n\tthis.renderer.dispose();\n\tthis.renderer=null;\n\tthis.orbitControls.dispose();\n\tthis.orbitControls=null;\n\tthis.preFocusPosition = null;;\n\tthis.camera.children.forEach(object => {\n\t    this.camera.remove(object);\n\t});\n\tthis.camera=null;\n    }\n\n    animate() {\n\tthis.render();\n\tthis.animationFrameId = requestAnimationFrame(this.animate.bind(this));\n    }\n\n    // TODO: expose a way to customize animating clouds in every axis\n    animateClouds() {\n\tconst globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n\t['x', 'y', 'z'].forEach(axis => {\n\t    globeClouds.rotation[axis] += Math.random() / 10000;\n\t});\n    }\n\n    // For each animation, update the focus and focusOptions provided by the animation over an array of timeouts\n    applyAnimations(animations) {\n\tconst currentFocus = this.focus;\n\tconst currentFocusOptions = this.options.focus;\n\n\tlet wait = 0;\n\tconst timeouts = [];\n\tanimations.forEach(animation => {\n\t    const {\n\t\tanimationDuration,\n\t\tcoordinates,\n\t\tdistanceRadiusScale,\n\t\teasingFunction,\n\t    } = animation;\n\t    const timeout = setTimeout(() => {\n\t\tthis.updateFocus(\n\t\t    coordinates,\n\t\t    {\n\t\t\tanimationDuration,\n\t\t\tdistanceRadiusScale,\n\t\t\teasingFunction,\n\t\t    },\n\t\t    true,\n\t\t);\n\t    }, wait);\n\t    timeouts.push(timeout);\n\t    wait += animationDuration;\n\t});\n\n\t// return cleanup function\n\treturn () => {\n\t    timeouts.forEach(timeout => {\n\t\tclearTimeout(timeout);\n\t    });\n\t    this.updateFocus(currentFocus, currentFocusOptions);\n\t};\n    }\n\n    enableOrbitControls(enabled, autoRotate = enabled) {\n\tthis.orbitControls.enabled = enabled;\n\tthis.orbitControls.autoRotate = autoRotate;\n    }\n\n    freeze() {\n\tthis.isFrozen = true;\n\tthis.enableOrbitControls(false);\n\tcancelAnimationFrame(this.animationFrameId);\n    }\n\n    getObjectByName(name) {\n\treturn this.scene.getObjectByName(name);\n    }\n\n    isFocusing() {\n\treturn !this.orbitControls.enabled;\n    }\n\n    render() {\n\tthis.renderer.sortObjects = false;\n\tthis.renderer.render(this.scene, this.camera);\n\tthis.animateClouds();\n\tthis.orbitControls.update();\n\tTWEEN.update();\n    }\n\n    updateCallbacks(callbacks = {}) {\n\tObject.keys(defaultCallbacks).forEach(key => {\n\t    this.callbacks[key] = callbacks[key] || defaultCallbacks[key];\n\t});\n    }\n\n    updateCamera(\n\tinitialCoordinates = INITIAL_COORDINATES,\n\tcameraOptions = {},\n    ) {\n\tthis.updateOptions(cameraOptions, 'camera');\n\tconst {\n\t    autoRotateSpeed,\n\t    distanceRadiusScale,\n\t    enableAutoRotate,\n\t    enableRotate,\n\t    enableZoom,\n\t    maxDistanceRadiusScale,\n\t    maxPolarAngle,\n\t    minPolarAngle,\n\t    rotateSpeed,\n\t    zoomSpeed,\n\t} = this.options.camera;\n\n\tif (this.initialCoordinates !== initialCoordinates) {\n\t    const [x, y, z] = coordinatesToPosition(\n\t\tinitialCoordinates,\n\t\tRADIUS * distanceRadiusScale,\n\t    );\n\t    this.camera.position.set(x, y, z);\n\t    this.initialCoordinates = initialCoordinates;\n\t}\n\n\tthis.camera.far = CAMERA_FAR;\n\tthis.camera.fov = CAMERA_FOV;\n\tthis.camera.near = CAMERA_NEAR;\n\tthis.orbitControls.autoRotate = enableAutoRotate;\n\tthis.orbitControls.autoRotateSpeed = autoRotateSpeed;\n\tthis.orbitControls.dampingFactor = CAMERA_DAMPING_FACTOR;\n\tthis.orbitControls.enableDamping = true;\n\tthis.orbitControls.enablePan = false;\n\tthis.orbitControls.enableRotate = enableRotate;\n\tthis.orbitControls.enableZoom = enableZoom;\n\tthis.orbitControls.maxDistance = RADIUS * maxDistanceRadiusScale;\n\tthis.orbitControls.maxPolarAngle = maxPolarAngle;\n\tthis.orbitControls.minDistance = RADIUS * CAMERA_MIN_DISTANCE_RADIUS_SCALE;\n\tthis.orbitControls.minPolarAngle = minPolarAngle;\n\tthis.orbitControls.rotateSpeed = rotateSpeed;\n\tthis.orbitControls.zoomSpeed = zoomSpeed;\n    }\n\n    updateFocus(\n\tfocus,\n\tfocusOptions = {},\n\tautoDefocus = false,\n    ) {\n\tthis.updateOptions(focusOptions, 'focus');\n\tthis.focus = focus;\n\n\tconst {\n\t    animationDuration,\n\t    distanceRadiusScale,\n\t    easingFunction,\n\t} = this.options.focus;\n\n\tif (this.isFrozen) {\n\t    return;\n\t}\n\n\tif (this.focus) {\n\t    // disable orbit controls when focused\n\t    const from = [\n\t\tthis.camera.position.x,\n\t\tthis.camera.position.y,\n\t\tthis.camera.position.z,\n\t    ];\n\t    const to = coordinatesToPosition(\n\t\tthis.focus,\n\t\tRADIUS * distanceRadiusScale,\n\t    );\n\t    this.preFocusPosition = this.preFocusPosition || ([...from]);\n\t    tween(\n\t\tfrom,\n\t\tto,\n\t\tanimationDuration,\n\t\teasingFunction,\n\t\t() => {\n\t\t    this.enableOrbitControls(false);\n\t\t    this.camera.position.set(...from);\n\t\t},\n\t\t() => {\n\t\t    if (autoDefocus) {\n\t\t\tthis.focus = undefined;\n\t\t\tthis.preFocusPosition = undefined;\n\t\t    }\n\t\t    this.enableOrbitControls(true, autoDefocus);\n\t\t},\n\t    );\n\t} else {\n\t    if (this.preFocusPosition) {\n\t\tconst from = [\n\t\t    this.camera.position.x,\n\t\t    this.camera.position.y,\n\t\t    this.camera.position.z,\n\t\t];\n\t\tconst to = this.preFocusPosition;\n\t\ttween(\n\t\t    from,\n\t\t    to,\n\t\t    animationDuration,\n\t\t    easingFunction,\n\t\t    () => {\n\t\t\tthis.enableOrbitControls(false);\n\t\t\tthis.camera.position.set(...from);\n\t\t    },\n\t\t    () => {\n\t\t\tthis.preFocusPosition = undefined;\n\t\t\tthis.enableOrbitControls(true);\n\t\t    },\n\t\t);\n\t    }\n\t}\n    }\n\n    updateGlobe(globeOptions = {}) {\n\tthis.updateOptions(globeOptions, 'globe');\n\tconst {\n\t    backgroundTexture,\n\t    cloudsOpacity,\n\t    cloudsTexture,\n\t    enableBackground,\n\t    enableClouds,\n\t    enableGlow,\n\t    glowColor,\n\t    glowCoefficient,\n\t    glowPower,\n\t    glowRadiusScale,\n\t    bumpMap,\n\t    texture,\n\t} = this.options.globe;\n\n\tconst globeBackground = this.getObjectByName(\n\t    ObjectName.GlobeBackground,\n\t);\n\tconst globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n\tconst globeSphere = this.getObjectByName(ObjectName.GlobeSphere);\n\n\tnew TextureLoader().load(texture, map => {\n\t    console.log(\"Loaded texture:\",texture);\n\t    new TextureLoader().load(bumpMap, bump => {\n\t\tconsole.log(\"Loaded bumpMap:\",bumpMap);\n\t\tglobeSphere.material = new MeshPhongMaterial({\n\t\t    map:map,\n\t\t    bumpMap:bump,   \n\t\t    bumpScale:5.0,\n\t\t}); //map,\n\n\t\tglobeSphere.geometry = new SphereGeometry(\n\t\t    RADIUS,\n\t\t    GLOBE_SEGMENTS,\n\t\t    GLOBE_SEGMENTS,\n\t\t);\n\t\t//globeSphere.material = new MeshLambertMaterial({\n\t\tif (enableGlow) {\n\t\t    if (this.getObjectByName(ObjectName.GlobeGlow) !== undefined) {\n\t\t\tglobeSphere.remove(this.getObjectByName(ObjectName.GlobeGlow));\n\t\t    };\n\t\t    const globeGlow = createGlowMesh(globeSphere.geometry, {\n\t\t\tbackside: true,\n\t\t\tcolor: glowColor,\n\t\t\tcoefficient: glowCoefficient,\n\t\t\tpower: glowPower,\n\t\t\tsize: RADIUS * glowRadiusScale,\n\t\t    });\n\t\t    globeGlow.name = ObjectName.GlobeGlow;\n\t\t    globeSphere.add(globeGlow);\n\t\t};\n\t\tthis.callbacks.onTextureLoaded();\n\t    });\n\t},undefined,(err) => {console.error('Error gl-texture: ',texture,err);});\n\n\tif (enableBackground) {\n\t    new TextureLoader().load(backgroundTexture,map => {\n\t\tglobeBackground.geometry = new SphereGeometry(\n\t\t    RADIUS * BACKGROUND_RADIUS_SCALE,\n\t\t    GLOBE_SEGMENTS,\n\t\t    GLOBE_SEGMENTS,\n\t\t);\n\t\tglobeBackground.material = new MeshBasicMaterial({\n\t\t    map,\n\t\t    side: BackSide,\n\t\t});\n\t    },undefined,(err) => {console.error('Error bg-texture: ',backgroundTexture,err);});\n\t}\n\tif (enableClouds) {\n            console.log(\"Loading cl texture:\",cloudsTexture);\n\t    new TextureLoader().load(cloudsTexture, map => {\n\t\tglobeClouds.geometry = new SphereGeometry(\n\t\t    RADIUS + CLOUDS_RADIUS_OFFSET,\n\t\t    GLOBE_SEGMENTS,\n\t\t    GLOBE_SEGMENTS,\n\t\t);\n\t\tglobeClouds.material = new MeshLambertMaterial({\n\t\t    map,\n\t\t    transparent: true,\n\t\t});\n\t\tglobeClouds.material.opacity = cloudsOpacity;\n\t    },undefined,(err) => {console.error('Error cl-texture: ',cloudsTexture,err);});\n\t}\n    }\n\n    updateLights(lightOptions = {}) {\n\tthis.updateOptions(lightOptions, 'light');\n\tconst {\n\t    ambientLightColor,\n\t    ambientLightIntensity,\n\t    pointLightColor,\n\t    pointLightIntensity,\n\t    pointLightPositionRadiusScales,\n\t} = this.options.light;\n\n\tconst cameraAmbientLight = this.getObjectByName(\n\t    ObjectName.CameraAmbientLight,\n\t);\n\tconst cameraPointLight = this.getObjectByName(\n\t    ObjectName.CameraPointLight,\n\t);\n\n\tcameraAmbientLight.color = new Color(ambientLightColor);\n\tcameraAmbientLight.intensity = ambientLightIntensity;\n\tcameraPointLight.color = new Color(pointLightColor);\n\tcameraPointLight.intensity = pointLightIntensity;\n\tcameraPointLight.position.set(\n\t    RADIUS * pointLightPositionRadiusScales[0],\n\t    RADIUS * pointLightPositionRadiusScales[1],\n\t    RADIUS * pointLightPositionRadiusScales[2],\n\t);\n    }\n\n    updateMarkers(\n\tmarkers = [],\n\tmarkerOptions = {},\n    ) {\n\tthis.updateOptions(markerOptions, 'marker');\n\tconst {\n\t    activeScale,\n\t    enableGlow,\n\t    enableTooltip,\n\t    enterAnimationDuration,\n\t    enterEasingFunction,\n\t    exitAnimationDuration,\n\t    exitEasingFunction,\n\t    glowCoefficient,\n\t    glowPower,\n\t    glowRadiusScale,\n\t    offsetRadiusScale,\n\t    radiusScaleRange,\n\t    renderer,\n\t    type,\n\t} = this.options.marker;\n\n\tconst unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE;\n\tconst sizeScale = scaleLinear()\n\t      .domain([\n\t\t  minValue(markers, marker => marker.value),\n\t\t  maxValue(markers, marker => marker.value),\n\t      ])\n\t      .range([RADIUS * radiusScaleRange[0], RADIUS * radiusScaleRange[1]]);\n\n\tconst markerCoordinatesKeys = new Set(markers.map(getMarkerCoordinatesKey));\n\tconst markerObjectNames = new Set(\n\t    this.markerObjects.children.map(markerObject => markerObject.name),\n\t);\n\n\tmarkers.forEach(marker => {\n\t    const { coordinates, value } = marker;\n\t    const markerCoordinatesKey = getMarkerCoordinatesKey(marker);\n\t    const size = sizeScale(value);\n\n\t    let markerObject;\n\t    // create new marker objects\n\t    if (!markerObjectNames.has(markerCoordinatesKey)) {\n\t\tif (renderer !== undefined) {\n\t\t    markerObject = renderer(marker);\n\t\t} else {\n\t\t    const color = marker.color || MARKER_DEFAULT_COLOR;\n\t\t    const from = { size: 0 };\n\t\t    const to = { size };\n\t\t    const mesh = new Mesh();\n\t\t    tween(from, to, enterAnimationDuration, enterEasingFunction, () => {\n\t\t\tswitch (type) {\n\t\t\tcase MarkerType.Bar:\n\t\t\t    mesh.geometry = new BoxGeometry(\n\t\t\t\tunitRadius,\n\t\t\t\tunitRadius,\n\t\t\t\tfrom.size,\n\t\t\t    );\n\t\t\t    mesh.material = new MeshLambertMaterial({\n\t\t\t\tcolor,\n\t\t\t    });\n\t\t\t    break;\n\t\t\tcase MarkerType.Dot:\n\t\t\tdefault:\n\t\t\t    mesh.geometry = new SphereGeometry(\n\t\t\t\tfrom.size,\n\t\t\t\tMARKER_SEGMENTS,\n\t\t\t\tMARKER_SEGMENTS,\n\t\t\t    );\n\t\t\t    mesh.material = new MeshBasicMaterial({ color });\n\t\t\t    if (enableGlow) {\n\t\t\t\t// add glow\n\t\t\t\tconst glowMesh = createGlowMesh(\n\t\t\t\t    mesh.geometry.clone(),\n\t\t\t\t    {\n\t\t\t\t\tbackside: false,\n\t\t\t\t\tcolor,\n\t\t\t\t\tcoefficient: glowCoefficient,\n\t\t\t\t\tpower: glowPower,\n\t\t\t\t\tsize: from.size * glowRadiusScale,\n\t\t\t\t    },\n\t\t\t\t);\n\t\t\t\tmesh.children = [];\n\t\t\t\tmesh.add(glowMesh);\n\t\t\t    }\n\t\t\t}\n\t\t    });\n\t\t    markerObject = mesh;\n\t\t}\n\n\t\t// place markers\n\t\tlet heightOffset = 0;\n\t\tif (offsetRadiusScale !== undefined) {\n\t\t    heightOffset = RADIUS * offsetRadiusScale;\n\t\t} else {\n\t\t    if (type === MarkerType.Dot) {\n\t\t\theightOffset = (size * (1 + glowRadiusScale)) / 2;\n\t\t    } else {\n\t\t\theightOffset = 0;\n\t\t    }\n\t\t}\n\t\tconst position = coordinatesToPosition(\n\t\t    coordinates,\n\t\t    RADIUS + heightOffset,\n\t\t);\n\t\tmarkerObject.position.set(...position);\n\t\tmarkerObject.lookAt(new Vector3(0, 0, 0));\n\n\t\tmarkerObject.name = markerCoordinatesKey;\n\t\tthis.markerObjects.add(markerObject);\n\t    }\n\n\t    // update existing marker objects\n\t    markerObject = this.markerObjects.getObjectByName(markerCoordinatesKey);\n\t    const handleClick = (event) => {\n\t\tevent.stopPropagation();\n\t\tthis.updateFocus(marker.coordinates);\n\t\tthis.callbacks.onClickMarker(\n\t\t    marker,\n\t\t    markerObject,\n\t\t    event.data.originalEvent,\n\t\t);\n\t    };\n\n\t    markerObject.on('click', handleClick.bind(this));\n\t    markerObject.on('touchstart', handleClick.bind(this));\n\t    markerObject.on('mousemove', event => {\n\t\tif (this.isFocusing()) {\n\t\t    this.tooltip.hide();\n\t\t    return;\n\t\t}\n\t\tconst { originalEvent } = event.data;\n\t\tif (enableTooltip) {\n\t\t    //console.log(\"Marker:\",JSON.stringify(marker.id));\n\t\t    this.tooltip.show(\n\t\t\toriginalEvent.clientX,\n\t\t\toriginalEvent.clientY,\n\t\t\tmarker\n\t\t    );\n\t\t}\n\t\tif (true) { return;};\n\t\tevent.stopPropagation();\n\t\tconst from = markerObject.scale.toArray();\n\t\ttween(\n\t\t    from,\n\t\t    [activeScale, activeScale, activeScale],\n\t\t    MARKER_ACTIVE_ANIMATION_DURATION,\n\t\t    MARKER_ACTIVE_ANIMATION_EASING_FUNCTION,\n\t\t    () => {\n\t\t\tif (markerObject) {\n\t\t\t    markerObject.scale.set(...from);\n\t\t\t}\n\t\t    },\n\t\t);\n\t\tthis.activeMarker = marker;\n\t\tthis.activeMarkerObject = markerObject;\n\t\tthis.callbacks.onMouseOverMarker(marker, markerObject, originalEvent);\n\t    });\n\t});\n\n\t// remove marker objects that are stale\n\tconst markerObjectsToRemove = this.markerObjects.children.filter(\n\t    markerObject => !markerCoordinatesKeys.has(markerObject.name),\n\t);\n\tmarkerObjectsToRemove.forEach(markerObject => {\n\t    const from = markerObject.scale.toArray();\n\t    tween(\n\t\tfrom,\n\t\t[0, 0, 0],\n\t\texitAnimationDuration,\n\t\texitEasingFunction,\n\t\t() => {\n\t\t    if (markerObject) {\n\t\t\tmarkerObject.scale.set(...from);\n\t\t    }\n\t\t},\n\t\t() => {\n\t\t    this.markerObjects.remove(markerObject);\n\t\t    this.cleanMarker(markerObject);\n\t\t},\n\t    );\n\t});\n    }\n\n    updateOptions(options, key) {\n\tthis.options = {\n\t    ...defaultOptions,\n\t    [key]: {\n\t\t...defaultOptions[key],\n\t\t...options,\n\t    },\n\t};\n    }\n\n    updateSize(size) {\n\tif (size) {\n\t    const [width, height] = size;\n\t    this.renderer.setSize(width, height);\n\t    this.camera.aspect = width / height;\n\t}\n\tthis.camera.updateProjectionMatrix();\n    }\n\n    unfreeze() {\n\tif (this.isFrozen) {\n\t    this.isFrozen = false;\n\t    this.enableOrbitControls(true);\n\t    this.animate();\n\t}\n    }\n}\n"]},"metadata":{},"sourceType":"module"}